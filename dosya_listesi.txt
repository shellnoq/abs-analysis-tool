FRONTEND KLASÃ–R YAPISI:
======================

ðŸ“¦src
  â”£ ðŸ“œApp.js
  â”£ ðŸ“œindex.css
  â”£ ðŸ“œindex.js
  â”£ ðŸ“‚components
    â”£ ðŸ“œFileUploader.js
    â”£ ðŸ“œFooter.js
    â”£ ðŸ“œTopBar.js
    â”£ ðŸ“‚calculation
      â”£ ðŸ“œCalculationResults.js
      â”£ ðŸ“œGeneralSettingsForm.js
      â”£ ðŸ“œInterestRatesTable.js
      â”£ ðŸ“œTrancheAForm.js
      â”£ ðŸ“œTrancheBForm.js
    â”£ ðŸ“‚optimization
      â”£ ðŸ“œOptimizationProgress.js
      â”£ ðŸ“œOptimizationResults.js
      â”£ ðŸ“œOptimizationSettingsForm.js
  â”£ ðŸ“‚contexts
    â”£ ðŸ“œDataContext.js
  â”£ ðŸ“‚pages
    â”£ ðŸ“œCalculationPage.js
    â”£ ðŸ“œCalculationResults.js
    â”£ ðŸ“œComparisonPage.js
    â”£ ðŸ“œHomePage.js
    â”£ ðŸ“œOptimizationPage.js
  â”£ ðŸ“‚services
    â”£ ðŸ“œapiService.js


BACKEND KLASÃ–R YAPISI:
=====================

ðŸ“¦backend
  â”£ ðŸ“œDockerfile
  â”£ ðŸ“œrequirements.txt
  â”£ ðŸ“‚app
    â”£ ðŸ“œmain.py
    â”£ ðŸ“œ__init__.py
    â”£ ðŸ“‚models
      â”£ ðŸ“œinput_models.py
      â”£ ðŸ“œoutput_models.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚routers
      â”£ ðŸ“œcalculation.py
      â”£ ðŸ“œoptimization.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚services
      â”£ ðŸ“œcalculation_service.py
      â”£ ðŸ“œoptimization_service.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚utils
      â”£ ðŸ“œcash_flow_utils.py
      â”£ ðŸ“œfinance_utils.py
      â”£ ðŸ“‚__pycache__
    â”£ ðŸ“‚__pycache__


FRONTEND DOSYALARI VE Ä°Ã‡ERÄ°KLERÄ°:
===============================

DOSYA: src\App.js
==================================================
// src/App.js
import React from "react";
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import { ThemeProvider, createTheme } from "@mui/material/styles";
import CssBaseline from "@mui/material/CssBaseline";

import TopBar from "./components/TopBar";
import Footer from "./components/Footer";
import HomePage from "./pages/HomePage";
import CalculationPage from "./pages/CalculationPage";
import OptimizationPage from "./pages/OptimizationPage";
import { DataProvider } from "./contexts/DataContext";
import ComparisonPage from "./pages/ComparisonPage";



const theme = createTheme({
  palette: {
    primary: {
      main: '#d32f2f', // Ana kÄ±rmÄ±zÄ±
      light: '#ef5350',
      dark: '#b71c1c',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#c2185b', // Pembe-kÄ±rmÄ±zÄ±
      light: '#e91e63',
      dark: '#880e4f',
      contrastText: '#ffffff',
    },
    error: {
      main: '#ff1744',
      light: '#ff4569',
      dark: '#d50000',
    },
    warning: {
      main: '#ff9100',
      light: '#ffb74d',
      dark: '#e65100',
    },
    info: {
      main: '#f44336',
      light: '#ef9a9a',
      dark: '#c62828',
    },
    success: {
      main: '#8bc34a',
      light: '#aed581',
      dark: '#689f38',
    },
    background: {
      default: '#fff5f5',
      paper: '#ffffff',
    },
    text: {
      primary: '#3e2723',
      secondary: '#5d4037',
    },
    divider: 'rgba(211, 47, 47, 0.12)',
  },
  typography: {
    fontFamily: '"Roboto", "Segoe UI", "Helvetica Neue", sans-serif',
    h4: {
      fontWeight: 500,
    },
    h5: {
      fontWeight: 500,
    },
    h6: {
      fontWeight: 500,
    },
    subtitle1: {
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
          borderRadius: 8,
        },
        elevation1: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
        },
        elevation2: {
          boxShadow: '0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12)',
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          fontWeight: 500,
          borderRadius: 6,
        },
        contained: {
          boxShadow: '0 1px 2px rgba(0,0,0,0.15)',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        head: {
          fontWeight: 600,
          backgroundColor: 'rgba(211, 47, 47, 0.05)',
        },
      },
    },
    MuiTableRow: {
      styleOverrides: {
        root: {
          '&:last-child td': {
            borderBottom: 0,
          },
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          boxShadow: '0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.04)',
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: 6,
        },
      },
    },
  },
});

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <DataProvider>
        <Router>
          <TopBar />
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route path="/calculation" element={<CalculationPage />} />
            <Route path="/optimization" element={<OptimizationPage />} />
            <Route path="/comparison" element={<ComparisonPage />} />
          </Routes>
          <Footer />
        </Router>
      </DataProvider>
    </ThemeProvider>
  );
}

export default App;

======================================================================

DOSYA: src\index.css
==================================================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

======================================================================

DOSYA: src\index.js
==================================================
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

======================================================================

DOSYA: src\components\FileUploader.js
==================================================
// src/components/FileUploader.js
import React, { useState } from "react";
import { 
  Box, 
  Button, 
  Typography, 
  Alert, 
  Paper, 
  CircularProgress,
  alpha
} from "@mui/material";
import UploadFileIcon from "@mui/icons-material/UploadFile";
import FileUploadOutlinedIcon from "@mui/icons-material/FileUploadOutlined";
import DescriptionOutlinedIcon from "@mui/icons-material/DescriptionOutlined";
import { uploadFile } from "../services/apiService";
import { useData } from "../contexts/DataContext";

const FileUploader = () => {
  const { setCashFlowData, setIsLoading, setError, isLoading, error, cashFlowData } = useData();

  const [file, setFile] = useState(null);
  const [dragActive, setDragActive] = useState(false);

  const handleDrag = (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      setFile(e.dataTransfer.files[0]);
    }
  };

  const handleChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setFile(e.target.files[0]);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!file) return;
    
    try {
      setIsLoading(true);
      setError(null);
      
      const data = await uploadFile(file);
      setCashFlowData(data);
    } catch (error) {
      setError('Failed to upload file. Please check the file format and try again.');
      console.error('Upload error:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <Box sx={{ width: '100%', maxWidth: 700, mx: 'auto', my: 3 }}>
      {error && (
        <Alert 
          severity="error" 
          sx={{ 
            mb: 3, 
            borderRadius: 2,
            '& .MuiAlert-icon': {
              alignItems: 'center'
            }
          }}
        >
          {error}
        </Alert>
      )}
      
      <form onSubmit={handleSubmit}>
        <Box
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
          sx={{
            border: '2px dashed',
            borderColor: dragActive ? 'primary.main' : (theme) => theme.palette.grey[300],
            borderRadius: 2,
            p: 4,
            mb: 3,
            textAlign: 'center',
            cursor: 'pointer',
            transition: 'all 0.2s ease-in-out',
            backgroundColor: dragActive 
              ? (theme) => alpha(theme.palette.primary.main, 0.08)
              : (theme) => alpha(theme.palette.background.paper, 0.5),
            '&:hover': {
              borderColor: 'primary.main',
              backgroundColor: (theme) => alpha(theme.palette.primary.main, 0.04)
            }
          }}
          onClick={() => document.getElementById('file-upload').click()}
        >
          <input
            type="file"
            id="file-upload"
            accept=".xlsx,.xls"
            onChange={handleChange}
            style={{ display: 'none' }}
          />
          {!file ? (
            <>
              <FileUploadOutlinedIcon sx={{ fontSize: 60, color: 'primary.main', mb: 2, opacity: 0.8 }} />
              <Typography variant="h6" gutterBottom fontWeight="medium" color="primary.main">
                Drag and drop your Excel file here
              </Typography>
              <Typography variant="body1" color="text.secondary">
                or click to browse files
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 2, opacity: 0.7 }}>
                Supported formats: .xlsx, .xls
              </Typography>
            </>
          ) : (
            <>
              <DescriptionOutlinedIcon sx={{ fontSize: 50, color: 'primary.main', mb: 2 }} />
              <Typography variant="h6" gutterBottom color="primary.main">
                File selected
              </Typography>
              <Typography variant="body1" fontWeight="medium">
                {file.name}
              </Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                Size: {(file.size / 1024).toFixed(1)} KB
              </Typography>
              <Typography variant="body2" color="primary.main" sx={{ mt: 2 }}>
                Click to select a different file
              </Typography>
            </>
          )}
        </Box>
        
        <Button
          type="submit"
          variant="contained"
          color="primary"
          fullWidth
          disabled={!file || isLoading}
          size="large"
          sx={{
            py: 1.5,
            fontWeight: 500,
            boxShadow: 2,
            '&:hover': {
              boxShadow: 3
            }
          }}
          startIcon={isLoading ? <CircularProgress size={24} color="inherit" /> : <UploadFileIcon />}
        >
          {isLoading ? 'Processing...' : 'Upload and Process'}
        </Button>
      </form>
      
      {/* Display data summary after upload */}
      {cashFlowData && !isLoading && !error && (
        <Paper 
          elevation={0} 
          sx={{ 
            mt: 4, 
            p: 3, 
            borderRadius: 2,
            border: (theme) => `1px solid ${alpha(theme.palette.success.main, 0.3)}`,
            backgroundColor: (theme) => alpha(theme.palette.success.main, 0.05)
          }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <DescriptionOutlinedIcon sx={{ color: 'success.main', mr: 1 }} />
            <Typography variant="h6" color="success.main" fontWeight="medium">
              File Uploaded Successfully
            </Typography>
          </Box>
          
          <Box sx={{ 
            mt: 2,
            p: 2,
            backgroundColor: 'background.paper',
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle2" gutterBottom color="text.secondary">
              Summary
            </Typography>
            
            <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3, mt: 1 }}>
              <Box>
                <Typography variant="body2" color="text.secondary">Total Records</Typography>
                <Typography variant="h6">{cashFlowData.total_records}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Principal</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_principal)}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Interest</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_interest)}</Typography>
              </Box>
              
              <Box>
                <Typography variant="body2" color="text.secondary">Total Cash Flow</Typography>
                <Typography variant="h6">{new Intl.NumberFormat('tr-TR', { style: 'currency', currency: 'TRY' }).format(cashFlowData.total_cash_flow)}</Typography>
              </Box>
            </Box>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              <b>Date Range:</b> {cashFlowData.date_range[0]} - {cashFlowData.date_range[1]}
            </Typography>
          </Box>
        </Paper>
      )}
    </Box>
  );
};

export default FileUploader;

======================================================================

DOSYA: src\components\Footer.js
==================================================
// frontend/src/components/Footer.js
import React from 'react';
import { Box, Typography, Container, Link } from '@mui/material';

const Footer = () => {
  return (
    <Box
      component="footer"
      sx={{
        py: 3,
        px: 2,
        mt: 'auto',
        backgroundColor: (theme) => theme.palette.grey[200],
      }}
    >
      <Container maxWidth="lg">
        <Typography variant="body2" color="text.secondary" align="center">
          Â© {new Date().getFullYear()} ABS Analysis Tool
        </Typography>
      </Container>
    </Box>
  );
};

export default Footer;

======================================================================

DOSYA: src\components\TopBar.js
==================================================
// frontend/src/components/TopBar.js
import React from 'react';
import { Link as RouterLink, useLocation } from 'react-router-dom';
import { AppBar, Toolbar, Typography, Button, Box, Container } from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import HomeIcon from '@mui/icons-material/Home';
import CompareIcon from '@mui/icons-material/Compare';
import { alpha } from '@mui/material/styles';


const TopBar = () => {
  const location = useLocation();
  
  return (
    <AppBar position="static" color="primary" elevation={0}>
      <Container maxWidth="lg">
        <Toolbar disableGutters>
          <Typography
            variant="h6"
            component={RouterLink}
            to="/"
            sx={{
              flexGrow: 1,
              textDecoration: 'none',
              color: 'inherit',
              display: 'flex',
              alignItems: 'center',
              fontWeight: 600,
            }}
          >
            ABS Analysis Tool
          </Typography>
          
          <Box sx={{ display: 'flex', gap: 1 }}>
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/"
              startIcon={<HomeIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Home
            </Button>
            
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/calculation"
              startIcon={<CalculateIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/calculation' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/calculation' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Calculate
            </Button>
            
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/optimization"
              startIcon={<OptimizeIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/optimization' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/optimization' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Optimize
            </Button>
            <Button 
              color="inherit" 
              component={RouterLink} 
              to="/comparison"
              startIcon={<CompareIcon />}
              sx={{
                px: 2,
                py: 1,
                borderRadius: 1,
                backgroundColor: location.pathname === '/comparison' ? alpha('#fff', 0.15) : 'transparent',
                '&:hover': {
                  backgroundColor: location.pathname === '/comparison' ? alpha('#fff', 0.25) : alpha('#fff', 0.1),
                }
              }}
            >
              Compare
            </Button>
          </Box>
        </Toolbar>
      </Container>
    </AppBar>
  );
};

export default TopBar;

======================================================================

DOSYA: src\components\calculation\CalculationResults.js
==================================================
// src/components/calculation/CalculationResults.js
import React from "react";
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  Chip,
  alpha
} from "@mui/material";
import { useTheme } from "@mui/material/styles";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from "recharts";
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';

const CalculationResults = ({ results }) => {
  const theme = useTheme();
  
  if (!results) {
    return (
      <Paper sx={{ 
        p: 4, 
        textAlign: "center", 
        borderRadius: 2,
        backgroundColor: alpha(theme.palette.info.light, 0.08),
        border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
      }}>
        <Typography variant="h6" color="text.secondary" gutterBottom>
          Results Not Available
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Please start the calculation process to view results
        </Typography>
      </Paper>
    );
  }
  
  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values with null check
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Extract color values from theme
  const classAColor = theme.palette.primary.main;
  const classBColor = theme.palette.secondary.main;
  
  // Prepare data for tranche comparison chart
  const chartData = [
    {
      name: "Class A",
      principal: results.class_a_principal || 0,
      interest: results.class_a_interest || 0,
      total: results.class_a_total || 0,
    },
    {
      name: "Class B",
      principal: results.class_b_principal || 0,
      coupon: results.class_b_coupon || 0,
      total: results.class_b_total || 0,
    },
  ];

  // Calculate totals with null checks
  const totalClassA = results.class_a_total || 0;
  const totalClassB = results.class_b_total || 0;
  const totalAll = totalClassA + totalClassB;
  
  // Check if minimum buffer requirement is met
  const minBufferTarget = 5.0;
  const isBufferMet = (results.min_buffer_actual || 0) >= minBufferTarget;

  return (
    <Box>
      {/* Summary Section */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03)
        }}
      >
        <Typography variant="h6" color="primary.main" gutterBottom fontWeight="medium">
          Calculation Results Summary
        </Typography>
        
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 3, mt: 2 }}>
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary">
              Payment Totals
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class A Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassA)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassA / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.primary.main, 0.1),
                          color: theme.palette.primary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class B Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassB)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassB / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Grand Total</TableCell>
                    <TableCell align="right">{formatCurrency(totalAll)}</TableCell>
                    <TableCell align="right">
                      <Chip 
                        size="small" 
                        label="100.00%"
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
          
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary">
              Principal and Interest
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classAColor,
                            mr: 1 
                          }} 
                        />
                        Class A
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_interest)}</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classBColor,
                            mr: 1 
                          }} 
                        />
                        Class B
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_coupon)}</TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Total</TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}
                    </TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
        </Box>
        
        <Divider sx={{ my: 3, opacity: 0.6 }} />
        
        <Box sx={{ 
          display: 'flex', 
          gap: 4, 
          flexWrap: 'wrap',
          backgroundColor: isBufferMet ? alpha(theme.palette.success.main, 0.08) : alpha(theme.palette.error.main, 0.08),
          p: 2,
          borderRadius: 1
        }}>
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Minimum Buffer Requirement
            </Typography>
            <Typography variant="h6" sx={{ mt: 0.5 }}>
              {formatPercent(minBufferTarget)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Actual Minimum Buffer (Class A)
            </Typography>
            <Typography variant="h6" color={isBufferMet ? "success.main" : "error.main"} sx={{ mt: 0.5 }}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box sx={{ ml: 'auto' }}>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Status
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
              {isBufferMet ? (
                <CheckCircleOutlineIcon color="success" sx={{ mr: 1 }} />
              ) : (
                <ErrorOutlineIcon color="error" sx={{ mr: 1 }} />
              )}
              <Typography 
                variant="h6" 
                color={isBufferMet ? "success.main" : "error.main"}
              >
                {isBufferMet ? "Requirement Met" : "Requirement Not Met"}
              </Typography>
            </Box>
          </Box>
        </Box>
      </Paper>
      
      {/* Financing Cost Analysis */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.info.main, 0.03)
        }}
      >
        <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
          Financing Cost Analysis
        </Typography>
        
        <TableContainer sx={{ 
          mt: 2,
          bgcolor: 'background.paper', 
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table>
            <TableBody>
              <TableRow>
                <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Principal Paid to Bank:</TableCell>
                <TableCell align="right" sx={{ fontWeight: 600, pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                  {formatCurrency(results.total_principal_paid)}
                </TableCell>
              </TableRow>
              <TableRow>
                <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Loan Principal:</TableCell>
                <TableCell align="right" sx={{ pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                  {formatCurrency(results.total_loan_principal)}
                </TableCell>
              </TableRow>
              <TableRow>
                <TableCell sx={{ pl: 2, fontWeight: 600 }}>
                  Financing {(results.financing_cost || 0) > 0 ? "Profit" : "Loss"}:
                </TableCell>
                <TableCell 
                  align="right" 
                  sx={{ 
                    fontWeight: 600,
                    pr: 2,
                    color: (results.financing_cost || 0) > 0 ? "success.main" : "error.main"
                  }}
                >
                  {formatCurrency(Math.abs(results.financing_cost || 0))}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Tranche Results Chart */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          backgroundColor: 'background.paper'
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Tranche Comparison
        </Typography>
        
        <Box sx={{ height: 400, mt: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip 
                formatter={(value) => formatCurrency(value)}
                contentStyle={{
                  borderRadius: 8,
                  border: 'none',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                }}
              />
              <Legend />
              <Bar 
                dataKey="principal" 
                name="Principal" 
                stackId="a" 
                fill={theme.palette.primary.main}
                radius={[4, 4, 0, 0]}
              />
              <Bar 
                dataKey="interest" 
                name="Interest" 
                stackId="a" 
                fill={theme.palette.primary.light}
                radius={[4, 4, 0, 0]}
              />
              <Bar 
                dataKey="coupon" 
                name="Coupon" 
                stackId="a" 
                fill={theme.palette.secondary.main}
                radius={[4, 4, 0, 0]}
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Detailed Results Table */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          backgroundColor: 'background.paper'
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Detailed Tranche Results
        </Typography>
        
        {results.tranche_results && results.tranche_results.length > 0 ? (
          <TableContainer sx={{ 
            maxHeight: 440,
            mt: 2,
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Table stickyHeader>
              <TableHead>
                <TableRow>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Date</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Principal</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Interest / Coupon</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Total Payment</TableCell>
                  <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Buffer Ratio (%)</TableCell>
                </TableRow>
              </TableHead>
              <TableBody>
                {results.tranche_results.map((tranche, index) => (
                  <TableRow 
                    key={index}
                    sx={{ 
                      backgroundColor: tranche["Is Class A"] 
                        ? alpha(theme.palette.primary.main, 0.03)
                        : alpha(theme.palette.secondary.main, 0.03),
                      '&:hover': {
                        backgroundColor: tranche["Is Class A"] 
                          ? alpha(theme.palette.primary.main, 0.07)
                          : alpha(theme.palette.secondary.main, 0.07),
                      }
                    }}
                  >
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: tranche["Is Class A"] ? classAColor : classBColor,
                            mr: 1 
                          }} 
                        />
                        {tranche["Tranche"]}
                      </Box>
                    </TableCell>
                    <TableCell>{tranche["Maturity Days"]}</TableCell>
                    <TableCell>{tranche["Maturity Date"]}</TableCell>
                    <TableCell>{formatCurrency(tranche["Principal"])}</TableCell>
                    <TableCell>
                      {formatCurrency(
                        tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"]
                      )}
                    </TableCell>
                    <TableCell>{formatCurrency(tranche["Total Payment"])}</TableCell>
                    <TableCell>
                      <Chip 
                        size="small" 
                        label={formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}
                        sx={{ 
                          bgcolor: 
                            tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                              ? alpha(theme.palette.success.main, 0.1)
                              : alpha(theme.palette.warning.main, 0.1),
                          color: 
                            tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                              ? theme.palette.success.main
                              : theme.palette.warning.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>
        ) : (
          <Typography variant="body2" color="text.secondary" sx={{ py: 3, textAlign: "center" }}>
            Detailed results are not available yet
          </Typography>
        )}
      </Paper>
    </Box>
  );
};

export default CalculationResults;

======================================================================

DOSYA: src\components\calculation\GeneralSettingsForm.js
==================================================
// frontend/src/components/calculation/GeneralSettingsForm.js
import React from 'react';
import { Box, Typography, TextField, Paper, Button } from '@mui/material';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { useData } from '../../contexts/DataContext';

const GeneralSettingsForm = () => {
  const { generalSettings, setGeneralSettings } = useData();

  const handleChange = (field, value) => {
    setGeneralSettings({
      ...generalSettings,
      [field]: value,
    });
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        General Settings
      </Typography>
      
      <Box sx={{ mt: 2 }}>
        <LocalizationProvider dateAdapter={AdapterDateFns}>
          <DatePicker
            label="Start Date"
            value={generalSettings.start_date}
            onChange={(newValue) => handleChange('start_date', newValue)}
            renderInput={(params) => <TextField {...params} fullWidth margin="normal" />}
          />
        </LocalizationProvider>
        
        <TextField
          fullWidth
          margin="normal"
          id="operational_expenses"
          label="Operational Expenses (â‚º)"
          type="number"
          value={generalSettings.operational_expenses}
          onChange={(e) => handleChange('operational_expenses', parseFloat(e.target.value))}
          InputProps={{
            inputProps: { min: 0, step: 1000 }
          }}
        />
        
        <TextField
          fullWidth
          margin="normal"
          id="min_buffer"
          label="Minimum Buffer (%)"
          type="number"
          value={generalSettings.min_buffer}
          onChange={(e) => handleChange('min_buffer', parseFloat(e.target.value))}
          InputProps={{
            inputProps: { min: 0, step: 0.5 }
          }}
        />
      </Box>
    </Paper>
  );
};

export default GeneralSettingsForm;

======================================================================

DOSYA: src\components\calculation\InterestRatesTable.js
==================================================
// frontend/src/components/calculation/InterestRatesTable.js
import React from 'react';
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  alpha,
  Chip
} from '@mui/material';
import { useTheme } from '@mui/material/styles';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

const InterestRatesTable = ({ results }) => {
  const theme = useTheme();
  
  // Format value function (handles '-' or number)
  const formatValue = (value) => {
    if (value === '-') return value;
    return `${parseFloat(value).toFixed(2)}%`;
  };

  // Prepare data for rates chart
  const chartData = results.interest_rate_conversions
    .filter(rate => rate.Tranche.includes('Class A'))
    .map(rate => ({
      name: rate.Tranche,
      rate: rate['Simple Annual Interest (%)'] === '-' ? 0 : rate['Simple Annual Interest (%)'],
    }))
    .concat(
      results.interest_rate_conversions
        .filter(rate => rate.Tranche.includes('Class B'))
        .map(rate => ({
          name: rate.Tranche,
          rate: rate['Effective Coupon Rate (%)'] === '-' ? 0 : rate['Effective Coupon Rate (%)'],
        }))
    );

  return (
    <Box>
      {/* Class B Coupon Information */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.secondary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.secondary.main, 0.05),
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom color="secondary.main" fontWeight="medium">
          Class B Coupon Information
        </Typography>
        
        <TableContainer sx={{ 
          backgroundColor: 'background.paper', 
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Tranche</TableCell>
                <TableCell align="center" sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Coupon Rate (%)</TableCell>
                <TableCell align="center" sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.secondary.main, 0.04) }}>Effective Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.interest_rate_conversions
                .filter(rate => rate.Tranche.includes('Class B'))
                .map((rate, index) => (
                  <TableRow key={index}>
                    <TableCell>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: theme.palette.secondary.main,
                            mr: 1 
                          }} 
                        />
                        {rate.Tranche}
                      </Box>
                    </TableCell>
                    <TableCell align="center">
                      <Chip 
                        size="small" 
                        label={formatValue(rate['Coupon Rate (%)'])}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                    <TableCell align="center">
                      <Chip 
                        size="small" 
                        label={formatValue(rate['Effective Coupon Rate (%)'])}
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                ))
              }
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Interest Rates Chart */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Interest Rates by Tranche
        </Typography>
        
        <Box sx={{ height: 400, mt: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={chartData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
              <XAxis dataKey="name" />
              <YAxis unit="%" />
              <Tooltip 
                formatter={(value) => `${value.toFixed(2)}%`}
                contentStyle={{
                  borderRadius: 8,
                  border: 'none',
                  boxShadow: '0 2px 8px rgba(0,0,0,0.15)'
                }}
              />
              <Legend />
              <Bar 
                dataKey="rate" 
                name="Rate" 
                fill={theme.palette.primary.main}
                radius={[4, 4, 0, 0]}
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Interest Rate Conversions Table */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
          borderRadius: 2
        }}
      >
        <Typography variant="h6" gutterBottom fontWeight="medium">
          Interest Rate Conversions
        </Typography>
        
        <TableContainer sx={{ 
          maxHeight: 440, 
          mt: 2,
          borderRadius: 1,
          boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
        }}>
          <Table stickyHeader>
            <TableHead>
              <TableRow>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Simple Annual Interest (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Compound Interest for Period (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Reinvest Simple Annual (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Reinvest O/N Compound (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Coupon Rate (%)</TableCell>
                <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Effective Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.interest_rate_conversions.map((rate, index) => (
                <TableRow 
                  key={index}
                  sx={{ 
                    backgroundColor: rate.Tranche.includes('Class A') 
                      ? alpha(theme.palette.primary.main, 0.03)
                      : alpha(theme.palette.secondary.main, 0.03),
                    '&:hover': {
                      backgroundColor: rate.Tranche.includes('Class A') 
                        ? alpha(theme.palette.primary.main, 0.07)
                        : alpha(theme.palette.secondary.main, 0.07),
                    }
                  }}
                >
                  <TableCell>
                    <Box sx={{ display: 'flex', alignItems: 'center' }}>
                      <Box 
                        component="span" 
                        sx={{ 
                          display: 'inline-block', 
                          width: 10, 
                          height: 10, 
                          borderRadius: '50%', 
                          bgcolor: rate.Tranche.includes('Class A') 
                            ? theme.palette.primary.main 
                            : theme.palette.secondary.main,
                          mr: 1 
                        }} 
                      />
                      {rate.Tranche}
                    </Box>
                  </TableCell>
                  <TableCell>{rate['Maturity Days']}</TableCell>
                  <TableCell>{formatValue(rate['Simple Annual Interest (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Compound Interest for Period (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Reinvest Simple Annual (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Reinvest O/N Compound (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Coupon Rate (%)'])}</TableCell>
                  <TableCell>{formatValue(rate['Effective Coupon Rate (%)'])}</TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
    </Box>
  );
};

export default InterestRatesTable;

======================================================================

DOSYA: src\components\calculation\TrancheAForm.js
==================================================
// frontend/src/components/calculation/TrancheAForm.js
import React from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  TextField,
  IconButton
} from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import DeleteIcon from '@mui/icons-material/Delete';
import { useData } from '../../contexts/DataContext';

const TrancheAForm = () => {
  const { tranchesA, setTranchesA } = useData();

  const handleChange = (index, field, value) => {
    const newTranches = [...tranchesA];
    newTranches[index][field] = value;
    setTranchesA(newTranches);
  };

  const handleAddTranche = () => {
    const newTranche = {
      maturity_days: 0,
      base_rate: 0.0,
      spread: 0.0,
      reinvest_rate: 0.0,
      nominal: 0
    };
    
    setTranchesA([...tranchesA, newTranche]);
  };

  const handleDeleteTranche = (index) => {
    const newTranches = tranchesA.filter((_, i) => i !== index);
    setTranchesA(newTranches);
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
        <Typography variant="h6">
          Class A Tranches
        </Typography>
        <IconButton 
          color="primary" 
          onClick={handleAddTranche}
          disabled={tranchesA.length >= 10}
        >
          <AddIcon />
        </IconButton>
      </Box>
      
      <TableContainer>
        <Table>
          <TableHead>
            <TableRow>
              <TableCell>Tranche</TableCell>
              <TableCell>Maturity Days</TableCell>
              <TableCell>Base Rate (%)</TableCell>
              <TableCell>Spread (bps)</TableCell>
              <TableCell>Reinvest Rate (%)</TableCell>
              <TableCell>Nominal (â‚º)</TableCell>
              <TableCell>Actions</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {tranchesA.map((tranche, index) => (
              <TableRow key={index}>
                <TableCell>{`A${index + 1}`}</TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.maturity_days}
                    onChange={(e) => handleChange(index, 'maturity_days', parseInt(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.base_rate}
                    onChange={(e) => handleChange(index, 'base_rate', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.spread}
                    onChange={(e) => handleChange(index, 'spread', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.reinvest_rate}
                    onChange={(e) => handleChange(index, 'reinvest_rate', parseFloat(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 0.1 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <TextField
                    type="number"
                    variant="outlined"
                    size="small"
                    value={tranche.nominal}
                    onChange={(e) => handleChange(index, 'nominal', parseInt(e.target.value) || 0)}
                    InputProps={{
                      inputProps: { min: 0, step: 1000000 }
                    }}
                  />
                </TableCell>
                <TableCell>
                  <IconButton 
                    color="error" 
                    onClick={() => handleDeleteTranche(index)}
                    disabled={tranchesA.length <= 1}
                  >
                    <DeleteIcon />
                  </IconButton>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Paper>
  );
};

export default TrancheAForm;

======================================================================

DOSYA: src\components\calculation\TrancheBForm.js
==================================================
// frontend/src/components/calculation/TrancheBForm.js
import React from 'react';
import { Box, Typography, TextField, Paper } from '@mui/material';
import { useData } from '../../contexts/DataContext';

const TrancheBForm = () => {
  const { trancheB, setTrancheB } = useData();

  const handleChange = (field, value) => {
    setTrancheB({
      ...trancheB,
      [field]: value,
    });
  };

  return (
    <Paper sx={{ p: 3, mb: 3 }}>
      <Typography variant="h6" gutterBottom>
        Class B Tranche
      </Typography>
      
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, mt: 2 }}>
        <TextField
          label="Maturity Days"
          type="number"
          value={trancheB.maturity_days}
          onChange={(e) => handleChange('maturity_days', parseInt(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0 }
          }}
        />
        
        <TextField
          label="Base Rate (%)"
          type="number"
          value={trancheB.base_rate}
          onChange={(e) => handleChange('base_rate', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
        
        <TextField
          label="Spread (bps)"
          type="number"
          value={trancheB.spread}
          onChange={(e) => handleChange('spread', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
        
        <TextField
          label="Reinvest Rate (%)"
          type="number"
          value={trancheB.reinvest_rate}
          onChange={(e) => handleChange('reinvest_rate', parseFloat(e.target.value) || 0)}
          sx={{ flex: '1 0 200px' }}
          InputProps={{
            inputProps: { min: 0, step: 0.1 }
          }}
        />
      </Box>
      
      <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
        Class B nominal amount will be automatically calculated as 10.17811704% of total.
      </Typography>
    </Paper>
  );
};

export default TrancheBForm;

======================================================================

DOSYA: src\components\optimization\OptimizationProgress.js
==================================================
// src/components/optimization/OptimizationProgress.js
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  LinearProgress, 
  Paper, 
  Divider,
  Chip,
  Button,
  alpha,
  useTheme
} from '@mui/material';
import RefreshIcon from '@mui/icons-material/Refresh';
import SpeedIcon from '@mui/icons-material/Speed';
import PendingIcon from '@mui/icons-material/Pending';
import SyncIcon from '@mui/icons-material/Sync';
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

const OptimizationProgress = ({ isOptimizing, onComplete }) => {
  const theme = useTheme();
  const [progress, setProgress] = useState(0);
  const [phase, setPhase] = useState('Initializing');
  const [message, setMessage] = useState('Starting optimization...');
  const [pollingActive, setPollingActive] = useState(false);
  const [pollCount, setPollCount] = useState(0);
  const [stuckDetected, setStuckDetected] = useState(false);
  const [lastProgressUpdate, setLastProgressUpdate] = useState(Date.now());
  const [lastProgressValue, setLastProgressValue] = useState(0);
  const [errorOccurred, setErrorOccurred] = useState(false);
  
  // Start polling when optimization starts
  useEffect(() => {
    if (isOptimizing && !pollingActive) {
      console.log("Starting optimization progress polling");
      setPollingActive(true);
      setProgress(0);
      setPhase('Initializing');
      setMessage('Starting optimization...');
      setPollCount(0);
      setStuckDetected(false);
      setLastProgressUpdate(Date.now());
      setLastProgressValue(0);
      setErrorOccurred(false);
    } else if (!isOptimizing && pollingActive) {
      console.log("Stopping optimization progress polling");
      setPollingActive(false);
    }
  }, [isOptimizing, pollingActive]);
  
  // Handle refresh button click
  const handleRefresh = () => {
    console.log("Refreshing optimization progress");
    if (stuckDetected) {
      setStuckDetected(false);
      setPollCount(0);
      setLastProgressUpdate(Date.now());
    }
  };
  
  // Polling effect
  useEffect(() => {
    let intervalId;
    
    if (pollingActive) {
      // Poll every second
      intervalId = setInterval(async () => {
        try {
          console.log("Polling optimization progress...");
          const response = await axios.get(`${API_URL}/optimize/progress/`);
          const data = response.data;
          
          console.log("Progress data:", data);
          
          // Check for error flag from backend
          if (data.error) {
            console.error("Error in optimization progress:", data.message);
            setErrorOccurred(true);
            setMessage(data.message || "Error in optimization process");
            setPhase("Error");
            // Don't update progress to indicate the error visually
            return;
          }
          
          // Check if progress has changed or message has changed
          const hasProgressChanged = data.progress !== progress;
          const hasMessageChanged = data.message !== message;
          
          if (hasProgressChanged || hasMessageChanged) {
            setProgress(data.progress);
            setPhase(data.phase);
            setMessage(data.message);
            setLastProgressUpdate(Date.now());
            
            if (hasProgressChanged) {
              setLastProgressValue(data.progress);
            }
          } else {
            // If no progress update, increment counter
            setPollCount(prev => prev + 1);
          }
          
          // Check for stuck progress - if no change for 30 seconds
          const timeSinceUpdate = Date.now() - lastProgressUpdate;
          if (pollCount > 30 && timeSinceUpdate > 30000) {
            console.log("Progress appears to be stuck");
            setStuckDetected(true);
          }
          
          // If progress is 100%, notify parent component
          if (data.progress >= 100) {
            console.log("Optimization completed (progress 100%)");
            setPollingActive(false);
            if (onComplete) {
              onComplete();
            }
          }
        } catch (error) {
          console.error('Error fetching optimization progress:', error);
          setPollCount(prev => prev + 1);
          
          // If we've had many errors, consider it stuck
          if (pollCount > 15) {
            console.log("Multiple polling errors, considering progress stuck");
            setStuckDetected(true);
          }
        }
      }, 1000);
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [pollingActive, onComplete, progress, message, pollCount, lastProgressUpdate, lastProgressValue]);
  
  // Auto-complete if we've been at 100% for a while
  useEffect(() => {
    if (progress >= 100 && pollingActive) {
      console.log("Progress is 100%, auto-completing after delay");
      const timeoutId = setTimeout(() => {
        setPollingActive(false);
        if (onComplete) {
          onComplete();
        }
      }, 2000);
      
      return () => clearTimeout(timeoutId);
    }
  }, [progress, pollingActive, onComplete]);
  
  if (!isOptimizing && progress === 0) {
    return null;
  }
  
  // Calculate progress color
  const getProgressColor = () => {
    if (errorOccurred) return theme.palette.error.main;
    if (stuckDetected) return theme.palette.warning.main;
    if (progress < 30) return theme.palette.info.main;
    if (progress < 70) return theme.palette.primary.main;
    return theme.palette.success.main;
  };
  
  // Progress icon
  const getProgressIcon = () => {
    if (errorOccurred) return <SyncIcon color="error" />;
    if (stuckDetected) return <SyncIcon color="warning" />;
    if (progress < 50) return <PendingIcon color="primary" />;
    return <SpeedIcon color="success" />;
  };
  
  return (
    <Paper 
      elevation={0} 
      sx={{ 
        p: 3, 
        mb: 3, 
        borderRadius: 2,
        border: errorOccurred 
          ? `1px solid ${alpha(theme.palette.error.main, 0.3)}`
          : stuckDetected 
            ? `1px solid ${alpha(theme.palette.warning.main, 0.3)}`
            : `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
        backgroundColor: errorOccurred
          ? alpha(theme.palette.error.main, 0.05)
          : stuckDetected
            ? alpha(theme.palette.warning.main, 0.05)
            : alpha(theme.palette.primary.main, 0.03)
      }}
    >
      <Box sx={{ mb: 2 }}>
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            {getProgressIcon()}
            <Typography variant="h6" sx={{ ml: 1 }}>
              {errorOccurred 
                ? 'Optimization Error' 
                : stuckDetected 
                  ? 'Optimization Progress (Stuck)' 
                  : 'Optimization Progress'}
            </Typography>
          </Box>
          <Chip 
            label={phase} 
            color={errorOccurred ? "error" : stuckDetected ? "warning" : "primary"} 
            variant="outlined"
            size="small"
          />
        </Box>
        <LinearProgress 
          variant="determinate" 
          value={progress} 
          sx={{ 
            height: 10, 
            borderRadius: 5,
            '& .MuiLinearProgress-bar': {
              borderRadius: 5,
              backgroundColor: getProgressColor()
            }
          }} 
        />
        <Box sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
          <Typography variant="body2" color="text.secondary">
            {message}
          </Typography>
          <Typography variant="body2" fontWeight="medium">
            {progress}%
          </Typography>
        </Box>
      </Box>
      
      <Divider sx={{ my: 1 }} />
      
      <Box sx={{ mt: 1, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="body2" color="text.secondary">
          {errorOccurred 
            ? "An error occurred during optimization. Please try again with different parameters."
            : stuckDetected 
              ? "Optimization might be stuck. The server is still processing, but progress updates have stopped." 
              : progress === 100 
                ? "Optimization completed successfully." 
                : "Please wait while the optimization is in progress..."}
        </Typography>
        
        {(stuckDetected || errorOccurred) && (
          <Button 
            variant="outlined" 
            color={errorOccurred ? "error" : "warning"} 
            size="small" 
            startIcon={<RefreshIcon />}
            onClick={handleRefresh}
            sx={{ ml: 2 }}
          >
            Refresh
          </Button>
        )}
      </Box>
    </Paper>
  );
};

export default OptimizationProgress;

======================================================================

DOSYA: src\components\optimization\OptimizationResults.js
==================================================
// src/components/optimization/OptimizationResults.js
import React, { useState } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Button,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Chip,
  useTheme,
  Snackbar,
  Alert
} from '@mui/material';
import { 
  BarChart, Bar, 
  PieChart, Pie, Cell, 
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer,
  Scatter, ScatterChart, ZAxis
} from 'recharts';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ReplayIcon from '@mui/icons-material/Replay';
import { useData } from '../../contexts/DataContext';
import { useNavigate } from 'react-router-dom';
import { calculateResults } from '../../services/apiService';

// Convert numbers to Roman numerals
const toRoman = (num) => {
  if (isNaN(num) || num < 1 || num > 3999) {
    return num.toString(); // Return the number as string if not a valid input
  }
  
  const romanNumerals = {
    M: 1000, CM: 900, D: 500, CD: 400,
    C: 100, XC: 90, L: 50, XL: 40,
    X: 10, IX: 9, V: 5, IV: 4, I: 1
  };
  
  let result = '';
  
  for (let key in romanNumerals) {
    while (num >= romanNumerals[key]) {
      result += key;
      num -= romanNumerals[key];
    }
  }
  
  return result;
};

// Strategy name mapping
const strategyNames = {
  equal: "Equal Distribution",
  increasing: "Increasing by Maturity",
  decreasing: "Decreasing by Maturity",
  middle_weighted: "Middle-Weighted",
  classic: "Standard Optimization",
  genetic: "Evolutionary Algorithm"
};

const OptimizationResults = ({ results }) => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { 
    setTranchesA, 
    setTrancheB, 
    calculationResults, 
    setPreviousCalculationResults, 
    originalTranchesA, 
    originalTrancheB,
    setIsLoading,
    setError,
    createCalculationRequest,
    setCalculationResults,
    setMultipleComparisonResults,
    setShouldAutoCalculate
  } = useData();
  
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState('success');
  
  // Format currency values
  const formatCurrency = (value) => {
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'TRY' }).format(value);
  };
  
  // Format percentage values
  const formatPercent = (value) => {
    return `${value.toFixed(2)}%`;
  };
  
  // Helper function to get strategy display name
  const getStrategyDisplayName = (strategy) => {
    return strategyNames[strategy] || strategy.charAt(0).toUpperCase() + strategy.slice(1);
  };
  
  // Prepare data for pie chart
  const pieData = [
    ...results.class_a_nominals.map((nominal, index) => ({
      name: `Class A${toRoman(index + 1)}`,
      value: nominal,
      color: theme.palette.primary.main
    })),
    { 
      name: `Class B${toRoman(1)}`, 
      value: results.class_b_nominal,
      color: theme.palette.secondary.main
    }
  ];
  
  // Prepare data for maturity distribution chart
  const maturityData = [
    ...results.class_a_maturities.map((maturity, index) => ({
      name: `Class A${toRoman(index + 1)}`,
      maturity,
      nominal: results.class_a_nominals[index],
      type: 'Class A'
    })),
    {
      name: `Class B${toRoman(1)}`,
      maturity: results.class_b_maturity,
      nominal: results.class_b_nominal,
      type: 'Class B'
    },
    {
      name: 'Last Cash Flow',
      maturity: results.last_cash_flow_day,
      nominal: Math.max(...results.class_a_nominals, results.class_b_nominal) / 20,
      type: 'Marker'
    }
  ];
  
  // Strategy comparison data
  const strategyResultsData = Object.entries(results.results_by_strategy).map(([strategy, data]) => ({
    name: getStrategyDisplayName(strategy),
    totalPrincipal: data.total_principal,
    classBCouponRate: data.class_b_coupon_rate,
    minBufferActual: data.min_buffer_actual,
    isBest: strategy === results.best_strategy
  }));
  
  // Apply the best strategy configuration to the forms and automatically calculate
  const applyConfiguration = async () => {
    try {
      // Store the current calculation results for comparison before we change the configuration
      if (calculationResults) {
        setPreviousCalculationResults(calculationResults);
      }
      
      const a_tranches = results.class_a_maturities.map((maturity, index) => ({
        maturity_days: maturity,
        base_rate: results.class_a_rates[index],
        spread: 0.0, // Default value
        reinvest_rate: results.class_a_reinvest[index],
        nominal: results.class_a_nominals[index]
      }));
      
      const b_tranche = {
        maturity_days: results.class_b_maturity,
        base_rate: results.class_b_rate,
        spread: 0.0, // Default value
        reinvest_rate: results.class_b_reinvest
      };
      
      // Update form state
      setTranchesA(a_tranches);
      setTrancheB(b_tranche);
      
      // Show processing message
      setSnackbarMessage('Applying configuration and calculating results...');
      setSnackbarSeverity('info');
      setSnackbarOpen(true);
      
      // Set flag to trigger auto-calculation when calculation page loads
      setShouldAutoCalculate(true);
      
      // Navigate to calculation page
      navigate('/calculation');
    } catch (error) {
      console.error('Error applying configuration:', error);
      
      // Show error message
      setSnackbarMessage('Error applying configuration. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    }
  };
  
  // Reset to original values
  const resetToOriginal = () => {
    try {
      if (originalTranchesA && originalTrancheB) {
        setTranchesA(JSON.parse(JSON.stringify(originalTranchesA)));
        setTrancheB(JSON.parse(JSON.stringify(originalTrancheB)));
        
        // Show success message
        setSnackbarMessage('Reset to original values successfully.');
        setSnackbarSeverity('success');
        setSnackbarOpen(true);
        
        // Navigate to calculation page
        navigate('/calculation');
      } else {
        // Show error message
        setSnackbarMessage('Original configuration not available.');
        setSnackbarSeverity('warning');
        setSnackbarOpen(true);
      }
    } catch (error) {
      console.error('Error resetting to original:', error);
      
      // Show error message
      setSnackbarMessage('Error resetting to original values.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    }
  };
  
  // Handle snackbar close
  const handleSnackbarClose = (event, reason) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  return (
    <Box>
      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleSnackbarClose} 
          severity={snackbarSeverity} 
          sx={{ width: '100%' }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
      
      {/* Summary Banner */}
      <Paper 
        sx={{ 
          p: 3, 
          mb: 3, 
          borderLeft: `4px solid ${theme.palette.secondary.main}`,
          backgroundColor: 'rgba(46, 204, 113, 0.1)'
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
          <Typography variant="h5" color="secondary">
            Optimal Structure Found
          </Typography>
          <Chip 
            icon={<CheckCircleIcon />} 
            label={getStrategyDisplayName(results.best_strategy)} 
            color="secondary" 
          />
        </Box>
        
        <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 4, mb: 3 }}>
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class A Tranches
            </Typography>
            <Typography variant="h6">
              {results.class_a_maturities.length}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class B Coupon Rate
            </Typography>
            <Typography variant="h6" color="secondary">
              {formatPercent(results.class_b_coupon_rate)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Minimum Buffer
            </Typography>
            <Typography variant="h6" color={results.min_buffer_actual >= 5.0 ? 'success.main' : 'error.main'}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary">
              Class B Maturity
            </Typography>
            <Typography variant="h6">
              {results.class_b_maturity} days
            </Typography>
          </Box>
        </Box>
        
        <Box sx={{ display: 'flex', gap: 2 }}>
          <Button 
            variant="contained" 
            color="secondary"
            size="large"
            onClick={applyConfiguration}
          >
            Apply This Configuration
          </Button>
          
          <Button 
            variant="outlined" 
            color="primary"
            size="large"
            startIcon={<ReplayIcon />}
            onClick={resetToOriginal}
          >
            Reset to Original Values
          </Button>
        </Box>
      </Paper>
      
      {/* Class B Maturity Calculation */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Class B Maturity Calculation
        </Typography>
        
        <Box sx={{ 
          display: 'flex', 
          flexWrap: 'wrap', 
          alignItems: 'center', 
          justifyContent: 'center',
          gap: 2, 
          my: 3 
        }}>
          <Paper sx={{ p: 2, bgcolor: 'grey.100', textAlign: 'center', minWidth: 180 }}>
            <Typography variant="body2" color="text.secondary">
              Last Cash Flow
            </Typography>
            <Typography variant="h5">
              {results.last_cash_flow_day} days
            </Typography>
          </Paper>
          
          <Typography variant="h4" color="text.secondary">+</Typography>
          
          <Paper sx={{ p: 2, bgcolor: 'grey.100', textAlign: 'center', minWidth: 180 }}>
            <Typography variant="body2" color="text.secondary">
              Additional Days
            </Typography>
            <Typography variant="h5">
              {results.additional_days} days
            </Typography>
          </Paper>
          
          <Typography variant="h4" color="text.secondary">=</Typography>
          
          <Paper sx={{ 
            p: 2, 
            bgcolor: theme.palette.secondary.main, 
            color: 'white',
            textAlign: 'center', 
            minWidth: 180 
          }}>
            <Typography variant="body2" sx={{ color: 'rgba(255,255,255,0.8)' }}>
              Class B Maturity
            </Typography>
            <Typography variant="h5">
              {results.class_b_maturity} days
            </Typography>
          </Paper>
        </Box>
        
        <Typography variant="body2" color="text.secondary" fontStyle="italic">
          Note: Class B maturity is calculated as Last Cash Flow Day + Additional Days.
          Maximum maturity is capped at 365 days.
        </Typography>
      </Paper>
      
      {/* Strategy Comparison */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Strategy Comparison
        </Typography>
        
        <TableContainer sx={{ mb: 3 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Strategy</TableCell>
                <TableCell align="right">Total Principal</TableCell>
                <TableCell align="right">Class B Coupon Rate</TableCell>
                <TableCell align="right">Min Buffer</TableCell>
                <TableCell align="right">Class A Tranches</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {strategyResultsData.map((row, index) => (
                <TableRow 
                  key={index}
                  sx={{ 
                    bgcolor: row.isBest ? 'rgba(46, 204, 113, 0.1)' : 'transparent',
                    fontWeight: row.isBest ? 'bold' : 'normal'
                  }}
                >
                  <TableCell>
                    <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                      {row.isBest && <CheckCircleIcon color="secondary" fontSize="small" />}
                      {row.name}
                    </Box>
                  </TableCell>
                  <TableCell align="right">{formatCurrency(row.totalPrincipal)}</TableCell>
                  <TableCell align="right">{formatPercent(row.classBCouponRate)}</TableCell>
                  <TableCell align="right">{formatPercent(row.minBufferActual)}</TableCell>
                  <TableCell align="right">
                    {results.results_by_strategy[Object.keys(results.results_by_strategy).find(key => (getStrategyDisplayName(key)) === row.name)]?.num_a_tranches || '-'}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
        
        {/* Strategy comparison charts */}
        <Box sx={{ height: 400, mb: 3 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={strategyResultsData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis />
              <Tooltip formatter={(value) => formatCurrency(value)} />
              <Legend />
              <Bar 
                dataKey="totalPrincipal" 
                name="Total Principal" 
                fill={theme.palette.primary.main} 
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
        
        <Box sx={{ height: 400 }}>
          <ResponsiveContainer width="100%" height="100%">
            <BarChart
              data={strategyResultsData}
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="name" />
              <YAxis unit="%" />
              <Tooltip formatter={(value) => `${value.toFixed(2)}%`} />
              <Legend />
              <Bar 
                dataKey="classBCouponRate" 
                name="Class B Coupon Rate" 
                fill={theme.palette.secondary.main} 
              />
              <Bar 
                dataKey="minBufferActual" 
                name="Min Buffer" 
                fill={theme.palette.info.main} 
              />
            </BarChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
      
      {/* Tranche Details */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Tranche Details
        </Typography>
        
        <Typography variant="subtitle1" gutterBottom sx={{ color: theme.palette.primary.main, mt: 3 }}>
          Class A Tranches
        </Typography>
        
        <TableContainer sx={{ mb: 3 }}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Tranche</TableCell>
                <TableCell align="right">Maturity (days)</TableCell>
                <TableCell align="right">Base Rate (%)</TableCell>
                <TableCell align="right">Reinvest Rate (%)</TableCell>
                <TableCell align="right">Nominal</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {results.class_a_maturities.map((maturity, index) => (
                <TableRow key={index}>
                  <TableCell>Class A{toRoman(index + 1)}</TableCell>
                  <TableCell align="right">{maturity}</TableCell>
                  <TableCell align="right">{results.class_a_rates[index].toFixed(2)}</TableCell>
                  <TableCell align="right">{results.class_a_reinvest[index].toFixed(2)}</TableCell>
                  <TableCell align="right">{formatCurrency(results.class_a_nominals[index])}</TableCell>
                </TableRow>
              ))}
              <TableRow sx={{ bgcolor: 'grey.100' }}>
                <TableCell sx={{ fontWeight: 'bold' }}>Total</TableCell>
                <TableCell></TableCell>
                <TableCell></TableCell>
                <TableCell></TableCell>
                <TableCell align="right" sx={{ fontWeight: 'bold' }}>
                  {formatCurrency(results.class_a_nominals.reduce((sum, nominal) => sum + nominal, 0))}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
        
        <Typography variant="subtitle1" gutterBottom sx={{ color: theme.palette.secondary.main, mt: 3 }}>
          Class B Tranche
        </Typography>
        
        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Tranche</TableCell>
                <TableCell align="right">Maturity (days)</TableCell>
                <TableCell align="right">Base Rate (%)</TableCell>
                <TableCell align="right">Reinvest Rate (%)</TableCell>
                <TableCell align="right">Nominal</TableCell>
                <TableCell align="right">Coupon Rate (%)</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              <TableRow>
                <TableCell>Class B{toRoman(1)}</TableCell>
                <TableCell align="right">{results.class_b_maturity}</TableCell>
                <TableCell align="right">{results.class_b_rate.toFixed(2)}</TableCell>
                <TableCell align="right">{results.class_b_reinvest.toFixed(2)}</TableCell>
                <TableCell align="right">{formatCurrency(results.class_b_nominal)}</TableCell>
                <TableCell align="right" sx={{ fontWeight: 'bold', color: theme.palette.secondary.main }}>
                  {formatPercent(results.class_b_coupon_rate)}
                </TableCell>
              </TableRow>
            </TableBody>
          </Table>
        </TableContainer>
      </Paper>
      
      {/* Visualizations */}
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="h6" gutterBottom>
          Visualizations
        </Typography>
        
        <Typography variant="subtitle1" gutterBottom sx={{ mt: 3 }}>
          Nominal Amount Distribution
        </Typography>
        
        <Box sx={{ height: 400, mb: 4 }}>
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={120}
                innerRadius={60}
                label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
              >
                {pieData.map((entry, index) => (
                  <Cell 
                    key={`cell-${index}`} 
                    fill={entry.name.includes('Class A') 
                      ? theme.palette.primary[index % 5 === 0 ? 'main' : `${Math.min(900, 300 + index * 100)}`]
                      : theme.palette.secondary.main
                    } 
                  />
                ))}
              </Pie>
              <Tooltip formatter={(value) => formatCurrency(value)} />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </Box>
        
        <Typography variant="subtitle1" gutterBottom sx={{ mt: 3 }}>
          Maturity Distribution
        </Typography>
        
        <Box sx={{ height: 400 }}>
          <ResponsiveContainer width="100%" height="100%">
            <ScatterChart
              margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                type="number" 
                dataKey="maturity" 
                name="Maturity" 
                unit=" days" 
                domain={[0, 'dataMax + 30']}
              />
              <YAxis 
                type="number" 
                dataKey="nominal" 
                name="Nominal" 
                tickFormatter={(value) => `${(value / 1000000).toFixed(0)}M`}
              />
              <ZAxis range={[100, 600]} />
              <Tooltip 
                formatter={(value, name, props) => {
                  if (name === 'Nominal') return formatCurrency(value);
                  return `${value} days`;
                }}
                content={({ active, payload }) => {
                  if (active && payload && payload.length) {
                    const data = payload[0].payload;
                    return (
                      <Box sx={{ bgcolor: 'background.paper', p: 1, border: '1px solid #ccc' }}>
                        <Typography variant="body2" fontWeight="bold">
                          {data.name}
                        </Typography>
                        <Typography variant="body2">
                          Maturity: {data.maturity} days
                        </Typography>
                        {data.type !== 'Marker' && (
                          <Typography variant="body2">
                            Nominal: {formatCurrency(data.nominal)}
                          </Typography>
                        )}
                      </Box>
                    );
                  }
                  return null;
                }}
              />
              <Legend />
              <Scatter 
                name="Class A" 
                data={maturityData.filter(d => d.type === 'Class A')}
                fill={theme.palette.primary.main}
              />
              <Scatter 
                name="Class B" 
                data={maturityData.filter(d => d.type === 'Class B')}
                fill={theme.palette.secondary.main}
              />
              <Scatter 
                name="Last Cash Flow" 
                data={maturityData.filter(d => d.type === 'Marker')}
                fill={theme.palette.error.main}
                shape="star"
              />
            </ScatterChart>
          </ResponsiveContainer>
        </Box>
      </Paper>
    </Box>
  );
};

export default OptimizationResults;

======================================================================

DOSYA: src\components\optimization\OptimizationSettingsForm.js
==================================================
// src/components/optimization/OptimizationSettingsForm.js
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Paper, 
  Slider, 
  TextField, 
  InputAdornment,
  FormControl,
  FormLabel,
  RadioGroup,
  Radio,
  FormControlLabel,
  ToggleButton,
  ToggleButtonGroup,
  Tooltip,
  IconButton,
  alpha,
  useTheme,
  Divider,
  Grid,
  Card,
  CardContent,
  Switch,
  FormGroup,
  Checkbox
} from '@mui/material';
import InfoIcon from '@mui/icons-material/Info';
import TuneIcon from '@mui/icons-material/Tune';
import AccountTreeIcon from '@mui/icons-material/AccountTree';
import BalanceIcon from '@mui/icons-material/Balance';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import TrendingDownIcon from '@mui/icons-material/TrendingDown';
import EqualizerIcon from '@mui/icons-material/Equalizer';
import SpeedIcon from '@mui/icons-material/Speed';

const OptimizationSettingsForm = ({ values, onChange }) => {
  const theme = useTheme();
  const [optimizationMethod, setOptimizationMethod] = useState(values.optimization_method || 'classic');
  const [selectedStrategies, setSelectedStrategies] = useState(values.selected_strategies || ['equal', 'increasing', 'decreasing', 'middle_weighted']);

  useEffect(() => {
    // Initialize selected strategies from props if available
    if (values.selected_strategies && values.selected_strategies.length > 0) {
      setSelectedStrategies(values.selected_strategies);
    }
  }, [values.selected_strategies]);

  const handleOptimizationMethodChange = (event) => {
    const newMethod = event.target.value;
    setOptimizationMethod(newMethod);
    onChange({ 
      ...values, 
      optimization_method: newMethod 
    });
  };

  const handleStrategiesChange = (event, newStrategies) => {
    // Ensure at least one strategy is selected
    if (newStrategies.length === 0) return;
    
    setSelectedStrategies(newStrategies);
    onChange({ 
      ...values, 
      selected_strategies: newStrategies 
    });
  };

  const handleSliderChange = (field) => (event, newValue) => {
    onChange({ ...values, [field]: newValue });
  };

  const handleInputChange = (field) => (event) => {
    const value = event.target.type === 'number' 
      ? parseFloat(event.target.value) 
      : event.target.value;
    onChange({ ...values, [field]: value });
  };

  // Method info details
  const methodInfo = {
    classic: {
      title: "Standard Optimization Strategies",
      icon: <TuneIcon sx={{ fontSize: 36, color: theme.palette.primary.main }} />,
      description: "Apply one or more traditional distribution strategies to optimize your tranche structure",
      color: theme.palette.primary.main
    },
    genetic: {
      title: "Evolutionary Algorithm",
      icon: <AccountTreeIcon sx={{ fontSize: 36, color: theme.palette.warning.main }} />,
      description: "Uses advanced genetic algorithms to intelligently search for optimal structures",
      color: theme.palette.warning.main
    }
  };

  // Strategy info
  const strategyInfo = {
    equal: {
      title: "Equal Distribution",
      icon: <BalanceIcon />,
      description: "Allocates equal nominal amounts across all tranches",
      color: theme.palette.primary.main
    },
    increasing: {
      title: "Increasing by Maturity",
      icon: <TrendingUpIcon />,
      description: "Higher allocations for longer maturity tranches",
      color: theme.palette.success.main
    },
    decreasing: {
      title: "Decreasing by Maturity",
      icon: <TrendingDownIcon />,
      description: "Higher allocations for shorter maturity tranches",
      color: theme.palette.error.main
    },
    middle_weighted: {
      title: "Middle-Weighted",
      icon: <EqualizerIcon />,
      description: "Higher allocations for middle maturity tranches",
      color: theme.palette.info.main
    }
  };

  return (
    <Box>
      <Typography variant="subtitle1" gutterBottom fontWeight="medium" sx={{ mb: 3 }}>
        Select an optimization method and configure parameters to find the optimal structure for your asset-backed securities
      </Typography>
      
      {/* Method Selection */}
      <Grid container spacing={3} sx={{ mb: 4 }}>
        {Object.keys(methodInfo).map((method) => (
          <Grid item xs={12} sm={6} key={method}>
            <Card 
              elevation={0}
              sx={{ 
                borderRadius: 2,
                border: `1px solid ${optimizationMethod === method 
                  ? alpha(methodInfo[method].color, 0.5) 
                  : alpha(theme.palette.text.primary, 0.08)}`,
                backgroundColor: optimizationMethod === method 
                  ? alpha(methodInfo[method].color, 0.05)
                  : 'background.paper',
                transition: 'all 0.2s ease-in-out',
                cursor: 'pointer',
                height: '100%',
                '&:hover': {
                  borderColor: alpha(methodInfo[method].color, 0.5),
                  backgroundColor: alpha(methodInfo[method].color, 0.03)
                }
              }}
              onClick={() => {
                setOptimizationMethod(method);
                onChange({ ...values, optimization_method: method });
              }}
            >
              <CardContent sx={{ p: 2.5 }}>
                <FormControlLabel
                  value={method}
                  control={
                    <Radio 
                      checked={optimizationMethod === method}
                      onChange={() => {}}
                      color={optimizationMethod === method ? undefined : "default"}
                    />
                  }
                  label={
                    <Box sx={{ ml: 0.5 }}>
                      {methodInfo[method].icon}
                      <Typography variant="subtitle1" sx={{ mt: 1.5, fontWeight: 500 }}>
                        {methodInfo[method].title}
                      </Typography>
                      <Typography variant="body2" color="text.secondary" sx={{ mt: 0.5, minHeight: 60 }}>
                        {methodInfo[method].description}
                      </Typography>
                    </Box>
                  }
                  sx={{ mx: 0, alignItems: 'flex-start', '& .MuiFormControlLabel-label': { width: '100%' } }}
                />
              </CardContent>
            </Card>
          </Grid>
        ))}
      </Grid>

      {/* Strategy Selection for Classic Method */}
      {optimizationMethod === 'classic' && (
        <Box sx={{ mb: 4, p: 3, backgroundColor: alpha(theme.palette.primary.light, 0.05), borderRadius: 2, border: `1px solid ${alpha(theme.palette.primary.main, 0.1)}` }}>
          <Typography variant="h6" gutterBottom color="primary.main" sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
            <TuneIcon sx={{ mr: 1 }} /> Select Optimization Strategies
            <Tooltip title="Select one or more strategies to include in the optimization process. The system will determine which strategy produces the best results." sx={{ ml: 1 }}>
              <IconButton size="small">
                <InfoIcon fontSize="small" />
              </IconButton>
            </Tooltip>
          </Typography>
          
          <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
            Select the strategies you want to include in the optimization process. The system will evaluate all selected strategies and identify the one that produces the best results.
          </Typography>
          
          <Grid container spacing={2}>
            {Object.keys(strategyInfo).map((strategy) => (
              <Grid item xs={12} sm={6} md={3} key={strategy}>
                <Paper 
                  elevation={0}
                  sx={{
                    p: 2,
                    border: `1px solid ${selectedStrategies.includes(strategy) 
                      ? alpha(strategyInfo[strategy].color, 0.5) 
                      : alpha(theme.palette.text.primary, 0.1)}`,
                    backgroundColor: selectedStrategies.includes(strategy) 
                      ? alpha(strategyInfo[strategy].color, 0.1)
                      : 'transparent',
                    borderRadius: 2,
                    cursor: 'pointer',
                    transition: 'all 0.2s',
                    display: 'flex',
                    flexDirection: 'column',
                    height: '100%',
                    '&:hover': {
                      borderColor: alpha(strategyInfo[strategy].color, 0.7),
                      backgroundColor: alpha(strategyInfo[strategy].color, 0.05)
                    }
                  }}
                  onClick={() => {
                    const newSelection = selectedStrategies.includes(strategy)
                      ? selectedStrategies.filter(s => s !== strategy)
                      : [...selectedStrategies, strategy];
                    
                    if (newSelection.length > 0) {
                      handleStrategiesChange(null, newSelection);
                    }
                  }}
                >
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
                    <Checkbox 
                      checked={selectedStrategies.includes(strategy)}
                      size="small"
                      sx={{ p: 0.5, mr: 1 }}
                      color={selectedStrategies.includes(strategy) ? undefined : "default"}
                    />
                    <Box sx={{ 
                      display: 'flex',
                      alignItems: 'center',
                      color: selectedStrategies.includes(strategy) 
                        ? strategyInfo[strategy].color 
                        : 'text.primary'
                    }}>
                      {React.cloneElement(strategyInfo[strategy].icon, { 
                        sx: { 
                          mr: 1,
                          color: selectedStrategies.includes(strategy) 
                            ? strategyInfo[strategy].color 
                            : 'text.secondary'
                        } 
                      })}
                      <Typography variant="subtitle2" fontWeight={500}>
                        {strategyInfo[strategy].title}
                      </Typography>
                    </Box>
                  </Box>
                  <Typography variant="body2" color="text.secondary" sx={{ mt: 1, fontSize: '0.8rem' }}>
                    {strategyInfo[strategy].description}
                  </Typography>
                </Paper>
              </Grid>
            ))}
          </Grid>
        </Box>
      )}

      <Divider sx={{ my: 3 }} />
      
      <Box sx={{ backgroundColor: alpha(theme.palette.background.paper, 0.7), p: 3, borderRadius: 2 }}>
        <Typography variant="h6" gutterBottom color={methodInfo[optimizationMethod].color}>
          {methodInfo[optimizationMethod].title} Configuration
        </Typography>
        
        {/* Method-specific settings */}
        {optimizationMethod === 'classic' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Standard Optimization Settings
            </Typography>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Class A Tranches Range</FormLabel>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Typography>{values.a_tranches_range[0]}</Typography>
                <Slider
                  value={values.a_tranches_range}
                  onChange={handleSliderChange('a_tranches_range')}
                  min={1}
                  max={10}
                  step={1}
                  valueLabelDisplay="auto"
                  aria-labelledby="a-tranches-range-slider"
                  sx={{ mx: 2 }}
                />
                <Typography>{values.a_tranches_range[1]}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary">
                Number of Class A tranches to consider in optimization
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Maturity Range (days)</FormLabel>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                <Typography>{values.maturity_range[0]}</Typography>
                <Slider
                  value={values.maturity_range}
                  onChange={handleSliderChange('maturity_range')}
                  min={30}
                  max={365}
                  step={5}
                  valueLabelDisplay="auto"
                  aria-labelledby="maturity-range-slider"
                  sx={{ mx: 2 }}
                />
                <Typography>{values.maturity_range[1]}</Typography>
              </Box>
              <Typography variant="body2" color="text.secondary">
                Range of maturity periods to consider in days
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Maturity Step</FormLabel>
              <Slider
                value={values.maturity_step}
                onChange={handleSliderChange('maturity_step')}
                min={5}
                max={30}
                step={5}
                valueLabelDisplay="auto"
                aria-labelledby="maturity-step-slider"
                marks={[
                  { value: 5, label: '5' },
                  { value: 10, label: '10' },
                  { value: 15, label: '15' },
                  { value: 20, label: '20' },
                  { value: 25, label: '25' },
                  { value: 30, label: '30' },
                ]}
              />
              <Typography variant="body2" color="text.secondary">
                Step size between maturity values
              </Typography>
            </FormControl>
          </Box>
        )}
        
        {optimizationMethod === 'genetic' && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom fontWeight="medium">
              Evolutionary Algorithm Settings
            </Typography>
            
            <FormControl fullWidth sx={{ mb: 2 }}>
              <FormLabel>Population Size</FormLabel>
              <Slider
                value={values.population_size || 50}
                onChange={(e, newValue) => onChange({ ...values, population_size: newValue })}
                min={10}
                max={100}
                step={5}
                valueLabelDisplay="auto"
                marks={[
                  { value: 10, label: '10' },
                  { value: 50, label: '50' },
                  { value: 100, label: '100' },
                ]}
              />
              <Typography variant="body2" color="text.secondary">
                Number of individuals in each generation - larger populations can find better solutions but take longer
              </Typography>
            </FormControl>
            
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Number of Generations</FormLabel>
              <Slider
                value={values.num_generations || 40}
                onChange={(e, newValue) => onChange({ ...values, num_generations: newValue })}
                min={10}
                max={100}
                step={5}
                valueLabelDisplay="auto"
                marks={[
                  { value: 10, label: '10' },
                  { value: 40, label: '40' },
                  { value: 100, label: '100' },
                ]}
              />
              <Typography variant="body2" color="text.secondary">
                Number of evolutionary cycles to run - more generations improve results but take longer
              </Typography>
            </FormControl>
          </Box>
        )}
        
        <Divider sx={{ my: 3 }} />
        
        {/* Common settings for all optimization methods */}
        <Typography variant="subtitle2" gutterBottom fontWeight="medium">
          Common Optimization Parameters
        </Typography>
        
        <Grid container spacing={3}>
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Minimum Class B Percentage</FormLabel>
              <TextField
                value={values.min_class_b_percent}
                onChange={handleInputChange('min_class_b_percent')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">%</InputAdornment>,
                  inputProps: { min: 5, max: 30, step: 0.5 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Minimum percentage of total nominal to allocate to Class B
              </Typography>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Target Class B Coupon Rate</FormLabel>
              <TextField
                value={values.target_class_b_coupon_rate}
                onChange={handleInputChange('target_class_b_coupon_rate')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">%</InputAdornment>,
                  inputProps: { min: 10, max: 100, step: 0.5 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Target annual coupon rate for Class B tranche
              </Typography>
            </FormControl>
          </Grid>
          
          <Grid item xs={12} md={4}>
            <FormControl fullWidth sx={{ mb: 4 }}>
              <FormLabel>Additional Days for Class B</FormLabel>
              <TextField
                value={values.additional_days_for_class_b}
                onChange={handleInputChange('additional_days_for_class_b')}
                type="number"
                InputProps={{
                  endAdornment: <InputAdornment position="end">days</InputAdornment>,
                  inputProps: { min: 1, max: 180, step: 1 }
                }}
                margin="normal"
              />
              <Typography variant="body2" color="text.secondary">
                Additional days to add to the last cash flow date for Class B maturity
              </Typography>
            </FormControl>
          </Grid>
        </Grid>
      </Box>
    </Box>
  );
};

export default OptimizationSettingsForm;

======================================================================

DOSYA: src\contexts\DataContext.js
==================================================
// frontend/src/contexts/DataContext.js
import React, { createContext, useState, useContext, useEffect } from 'react';

const DataContext = createContext();

export const useData = () => useContext(DataContext);

export const DataProvider = ({ children }) => {
  // File upload and data state
  const [cashFlowData, setCashFlowData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Calculation form state
  const [generalSettings, setGeneralSettings] = useState({
    start_date: new Date(2025, 1, 13),
    operational_expenses: 7928640,
    min_buffer: 5.0
  });
  
  const [tranchesA, setTranchesA] = useState([
    { maturity_days: 61, base_rate: 45.6, spread: 0.0, reinvest_rate: 40.0, nominal: 480000000 },
    { maturity_days: 120, base_rate: 44.5, spread: 0.0, reinvest_rate: 37.25, nominal: 460000000 },
    { maturity_days: 182, base_rate: 43.3, spread: 0.0, reinvest_rate: 32.5, nominal: 425000000 },
    { maturity_days: 274, base_rate: 42.5, spread: 0.0, reinvest_rate: 30.0, nominal: 400000000 },
  ]);
  
  // Store original tranche values for reset functionality
  const [originalTranchesA, setOriginalTranchesA] = useState(null);
  const [originalTrancheB, setOriginalTrancheB] = useState(null);
  
  const [trancheB, setTrancheB] = useState({
    maturity_days: 300,
    base_rate: 0.0,
    spread: 0.0,
    reinvest_rate: 25.5
  });
  
  const [npvSettings, setNpvSettings] = useState({
    method: 'weighted_avg_rate',
    custom_rate: 40.0
  });
  
  // Flag for auto-calculating when navigating from optimization page
  const [shouldAutoCalculate, setShouldAutoCalculate] = useState(false);
  
  // Results state with localStorage initialization
  const [calculationResults, setCalculationResults] = useState(() => {
    const saved = localStorage.getItem('calculationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  const [optimizationResults, setOptimizationResults] = useState(() => {
    const saved = localStorage.getItem('optimizationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  const [previousCalculationResults, setPreviousCalculationResults] = useState(() => {
    const saved = localStorage.getItem('previousCalculationResults');
    return saved ? JSON.parse(saved) : null;
  });
  
  // New state for multiple comparison results
  const [multipleComparisonResults, setMultipleComparisonResults] = useState(() => {
    const saved = localStorage.getItem('multipleComparisonResults');
    return saved ? JSON.parse(saved) : [];
  });
  
  // Wrap setState functions to also update localStorage
  const setCalculationResultsWithStorage = (results) => {
    setCalculationResults(results);
    localStorage.setItem('calculationResults', JSON.stringify(results));
  };
  
  const setOptimizationResultsWithStorage = (results) => {
    setOptimizationResults(results);
    localStorage.setItem('optimizationResults', JSON.stringify(results));
  };
  
  const setPreviousCalculationResultsWithStorage = (results) => {
    setPreviousCalculationResults(results);
    localStorage.setItem('previousCalculationResults', JSON.stringify(results));
  };
  
  const setMultipleComparisonResultsWithStorage = (results) => {
    setMultipleComparisonResults(results);
    localStorage.setItem('multipleComparisonResults', JSON.stringify(results));
  };
  
  // Store original values when first loading
  useEffect(() => {
    if (!originalTranchesA) {
      setOriginalTranchesA(JSON.parse(JSON.stringify(tranchesA)));
    }
    if (!originalTrancheB) {
      setOriginalTrancheB(JSON.parse(JSON.stringify(trancheB)));
    }
  }, []);
  
  // Update localStorage when state changes
  useEffect(() => {
    if (calculationResults) {
      localStorage.setItem('calculationResults', JSON.stringify(calculationResults));
    }
  }, [calculationResults]);
  
  useEffect(() => {
    if (optimizationResults) {
      localStorage.setItem('optimizationResults', JSON.stringify(optimizationResults));
    }
  }, [optimizationResults]);
  
  useEffect(() => {
    if (previousCalculationResults) {
      localStorage.setItem('previousCalculationResults', JSON.stringify(previousCalculationResults));
    }
  }, [previousCalculationResults]);
  
  useEffect(() => {
    if (multipleComparisonResults) {
      localStorage.setItem('multipleComparisonResults', JSON.stringify(multipleComparisonResults));
    }
  }, [multipleComparisonResults]);
  
  // Optimization settings - Updated with new method options
  const [optimizationSettings, setOptimizationSettings] = useState({
    optimization_method: 'classic', // Default to classic
    a_tranches_range: [2, 6],
    maturity_range: [32, 365],
    maturity_step: 10,
    min_class_b_percent: 10.0,
    target_class_b_coupon_rate: 30.0,
    additional_days_for_class_b: 10,
    // Genetic algorithm settings
    population_size: 50,
    num_generations: 40
    // Removed Gradient descent and Bayesian options
  });

  // Helper function to reset to default values
  const resetToDefaults = () => {
    if (originalTranchesA && originalTrancheB) {
      setTranchesA(JSON.parse(JSON.stringify(originalTranchesA)));
      setTrancheB(JSON.parse(JSON.stringify(originalTrancheB)));
      return true;
    }
    return false;
  };

  // Helper function to clear data
  const clearData = () => {
    setCashFlowData(null);
    setCalculationResultsWithStorage(null); // Use wrapper
    setOptimizationResultsWithStorage(null); // Use wrapper
    setError(null);
    
    // Also clear from localStorage
    localStorage.removeItem('calculationResults');
    localStorage.removeItem('optimizationResults');
  };

  // Create calculation request payload
  const createCalculationRequest = () => {
    return {
      general_settings: {
        start_date: generalSettings.start_date.toISOString().split('T')[0],
        operational_expenses: generalSettings.operational_expenses,
        min_buffer: generalSettings.min_buffer
      },
      tranches_a: tranchesA,
      tranche_b: trancheB,
      npv_settings: npvSettings
    };
  };

  // Create optimization request payload
  const createOptimizationRequest = () => {
    return {
      optimization_settings: optimizationSettings,
      general_settings: {
        start_date: generalSettings.start_date.toISOString().split('T')[0],
        operational_expenses: generalSettings.operational_expenses,
        min_buffer: generalSettings.min_buffer
      }
    };
  };

  const value = {
    // Data state
    cashFlowData,
    setCashFlowData,
    isLoading,
    setIsLoading,
    error,
    setError,
    
    // Form state
    generalSettings,
    setGeneralSettings,
    tranchesA,
    setTranchesA,
    trancheB,
    setTrancheB,
    npvSettings,
    setNpvSettings,
    
    // Auto-calculate flag
    shouldAutoCalculate,
    setShouldAutoCalculate,
    
    // Original values for reset
    originalTranchesA,
    originalTrancheB,
    
    // Results state - use wrapper functions instead of direct setState
    calculationResults,
    setCalculationResults: setCalculationResultsWithStorage,
    optimizationResults,
    setOptimizationResults: setOptimizationResultsWithStorage,
    previousCalculationResults,
    setPreviousCalculationResults: setPreviousCalculationResultsWithStorage,
    
    // Multiple comparison results
    multipleComparisonResults,
    setMultipleComparisonResults: setMultipleComparisonResultsWithStorage,
    
    // Optimization settings
    optimizationSettings,
    setOptimizationSettings,
    
    // Helper functions
    clearData,
    createCalculationRequest,
    createOptimizationRequest,
    resetToDefaults
  };

  return <DataContext.Provider value={value}>{children}</DataContext.Provider>;
};

======================================================================

DOSYA: src\pages\CalculationPage.js
==================================================
// frontend/src/pages/CalculationPage.js
import React, { useState, useEffect } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Tabs, 
  Tab, 
  Button, 
  Alert,
  CircularProgress,
  Snackbar,
  IconButton,
  Tooltip,
  Divider
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import CompareIcon from '@mui/icons-material/Compare';
import ReplayIcon from '@mui/icons-material/Replay';
import { useData } from '../contexts/DataContext';
import { calculateResults } from '../services/apiService';
import GeneralSettingsForm from '../components/calculation/GeneralSettingsForm';
import TrancheAForm from '../components/calculation/TrancheAForm';
import TrancheBForm from '../components/calculation/TrancheBForm';
import CalculationResults from './CalculationResults';
import InterestRatesTable from '../components/calculation/InterestRatesTable';
import { useNavigate } from 'react-router-dom';

const CalculationPage = () => {
  const navigate = useNavigate();
  const { 
    cashFlowData,
    calculationResults, 
    setCalculationResults,
    isLoading,
    setIsLoading,
    error,
    setError,
    createCalculationRequest,
    previousCalculationResults,
    resetToDefaults,
    multipleComparisonResults,
    setMultipleComparisonResults,
    shouldAutoCalculate,
    setShouldAutoCalculate
  } = useData();
  
  const [tabValue, setTabValue] = useState(0);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [snackbarMessage, setSnackbarMessage] = useState('');
  const [snackbarSeverity, setSnackbarSeverity] = useState('success');
  
  // Auto-calculate when shouldAutoCalculate flag is true
  useEffect(() => {
    if (shouldAutoCalculate) {
      handleCalculate();
      setShouldAutoCalculate(false); // Reset the flag after processing
    }
  }, [shouldAutoCalculate, setShouldAutoCalculate]);

  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  const handleCalculate = async () => {
    try {
      setIsLoading(true);
      setError(null);
      
      const request = createCalculationRequest();
      const results = await calculateResults(request);
      
      // Add metadata for tracking and display
      if (!results.is_optimized) {
        // This is a manual calculation
        results.label = 'Manual Calculation';
        results.timestamp = new Date().toISOString();
      } else {
        // For optimized calculations, use the optimization method name
        const methodDisplayNames = {
          'classic': 'Classic Strategy',
          'genetic': 'Genetic Algorithm',
          'equal': 'Equal Distribution',
          'increasing': 'Increasing by Maturity', 
          'decreasing': 'Decreasing by Maturity',
          'middle_weighted': 'Middle Weighted'
        };
        
        const methodName = results.optimization_method || 'Optimized';
        results.label = `${methodDisplayNames[methodName] || methodName} Optimization`;
        results.timestamp = new Date().toISOString();
      }
      
      setCalculationResults(results);
      setTabValue(1); // Switch to results tab
      
      // Add to comparison history if it's a new calculation
      if (!calculationResults || 
          JSON.stringify(results) !== JSON.stringify(calculationResults)) {
        
        setMultipleComparisonResults(prev => {
          // Create a new array to avoid reference issues
          const updatedResults = prev ? [...prev] : [];
          
          // Check if we've reached the maximum number of comparisons (limit to 5 for UI reasons)
          if (updatedResults.length >= 5) {
            updatedResults.shift(); // Remove the oldest result
          }
          
          // Add the new result with its label
          updatedResults.push({
            ...results,
            timestamp: new Date().toISOString()
          });
          
          return updatedResults;
        });
      }
      
      // Show success message
      setSnackbarMessage('Calculation completed successfully!');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
      
      // Logging to ensure we have data for comparison
      console.log("Calculation results saved:", results);
      console.log("Previous results available:", previousCalculationResults ? "Yes" : "No");
    } catch (err) {
      setError('Calculation failed. Please check your parameters and try again.');
      console.error(err);
      
      // Show error message
      setSnackbarMessage('Calculation failed. Please try again.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    } finally {
      setIsLoading(false);
    }
  };
  
  // Reset to original default values
  const handleReset = () => {
    if (resetToDefaults()) {
      setSnackbarMessage('Reset to original values successfully.');
      setSnackbarSeverity('success');
      setSnackbarOpen(true);
    } else {
      setSnackbarMessage('Failed to reset to original values.');
      setSnackbarSeverity('error');
      setSnackbarOpen(true);
    }
  };
  
  // Navigate to comparison page
  const goToComparison = () => {
    navigate('/comparison');
  };
  
  // Handle snackbar close
  const handleSnackbarClose = (event, reason) => {
    if (reason === 'clickaway') {
      return;
    }
    setSnackbarOpen(false);
  };

  if (!cashFlowData) {
    return (
      <Container>
        <Box sx={{ mt: 4, textAlign: 'center' }}>
          <Typography variant="h5" color="error">
            Please upload cash flow data first
          </Typography>
        </Box>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      {/* Snackbar for notifications */}
      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'top', horizontal: 'center' }}
      >
        <Alert 
          onClose={handleSnackbarClose} 
          severity={snackbarSeverity} 
          sx={{ width: '100%' }}
        >
          {snackbarMessage}
        </Alert>
      </Snackbar>
    
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4" gutterBottom>
          ABS Calculation
        </Typography>
        
        <Box sx={{ display: 'flex', gap: 2 }}>
          {calculationResults && previousCalculationResults && (
            <Button
              variant="outlined"
              color="primary"
              onClick={goToComparison}
              startIcon={<CompareIcon />}
            >
              View Comparisons
            </Button>
          )}
          
          <Tooltip title="Reset to original values">
            <IconButton 
              color="primary" 
              onClick={handleReset}
              size="small"
            >
              <ReplayIcon />
            </IconButton>
          </Tooltip>
        </Box>
      </Box>
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>
      )}
      
      <Paper sx={{ mb: 4 }}>
        <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
          <Tabs value={tabValue} onChange={handleTabChange}>
            <Tab label="Input Parameters" />
            <Tab label="Results" disabled={!calculationResults} />
            <Tab label="Interest Rates" disabled={!calculationResults} />
          </Tabs>
        </Box>
        
        <Box sx={{ p: 3 }}>
          {tabValue === 0 && (
            <>
              <GeneralSettingsForm />
              <TrancheAForm />
              <TrancheBForm />
              
              <Divider sx={{ my: 3 }} />
              
              <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center', gap: 2 }}>
                <Button
                  variant="contained"
                  color="primary"
                  size="large"
                  onClick={handleCalculate}
                  disabled={isLoading}
                  startIcon={isLoading ? <CircularProgress size={24} /> : <CalculateIcon />}
                >
                  {isLoading ? 'Calculating...' : 'Calculate Results'}
                </Button>
                
                {calculationResults && previousCalculationResults && (
                  <Button
                    variant="outlined"
                    color="primary"
                    size="large"
                    onClick={goToComparison}
                    startIcon={<CompareIcon />}
                  >
                    Compare Results
                  </Button>
                )}
              </Box>
            </>
          )}
          
          {tabValue === 1 && calculationResults && (
            <CalculationResults results={calculationResults} />
          )}
          
          {tabValue === 2 && calculationResults && (
            <InterestRatesTable results={calculationResults} />
          )}
        </Box>
      </Paper>
    </Container>
  );
};

export default CalculationPage;

======================================================================

DOSYA: src\pages\CalculationResults.js
==================================================
// src/components/calculation/CalculationResults.js
import React, { useState } from "react";
import { 
  Box, 
  Typography, 
  Paper,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Divider,
  Chip,
  alpha,
  Tabs,
  Tab,
  Grid,
  Card,
  CardContent,
  useTheme,
} from "@mui/material";
import { BarChart, Bar, PieChart, Pie, Cell, LineChart, Line, ScatterChart, Scatter, ZAxis,
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, AreaChart, Area, ReferenceLine } from "recharts";
import CheckCircleOutlineIcon from '@mui/icons-material/CheckCircleOutline';
import ErrorOutlineIcon from '@mui/icons-material/ErrorOutline';
import TimelineIcon from '@mui/icons-material/Timeline';
import PieChartIcon from '@mui/icons-material/PieChart';
import BarChartIcon from '@mui/icons-material/BarChart';
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import TableChartIcon from '@mui/icons-material/TableChart';
import ShowChartIcon from '@mui/icons-material/ShowChart';

// Custom tooltip component for charts
const CustomTooltip = ({ active, payload, label, formatter }) => {
  const theme = useTheme();
  if (active && payload && payload.length) {
    return (
      <Paper
        sx={{
          p: 1.5,
          boxShadow: "0 2px 12px rgba(0,0,0,0.15)",
          borderRadius: 1,
          border: "none",
          minWidth: 180,
        }}
      >
        <Typography variant="subtitle2" sx={{ mb: 0.5 }}>{label}</Typography>
        {payload.map((entry, index) => (
          <Box key={`item-${index}`} sx={{ color: entry.color, display: 'flex', justifyContent: 'space-between', my: 0.5 }}>
            <Typography variant="body2" sx={{ mr: 2 }}>
              {entry.name}:
            </Typography>
            <Typography variant="body2" fontWeight="medium">
              {formatter ? formatter(entry.value) : entry.value}
            </Typography>
          </Box>
        ))}
      </Paper>
    );
  }
  return null;
};

const CalculationResults = ({ results }) => {
  const theme = useTheme();
  const [tabValue, setTabValue] = useState(0);
  
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  if (!results) {
    return (
      <Paper sx={{ 
        p: 4, 
        textAlign: "center", 
        borderRadius: 2,
        backgroundColor: alpha(theme.palette.info.light, 0.08),
        border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
      }}>
        <Typography variant="h6" color="text.secondary" gutterBottom>
          Results Not Available
        </Typography>
        <Typography variant="body2" color="text.secondary">
          Please start the calculation process to view results
        </Typography>
      </Paper>
    );
  }
  
  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values with null check
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Extract color values from theme
  const classAColor = theme.palette.primary.main;
  const classBColor = theme.palette.secondary.main;
  
  // Calculate totals with null checks
  const totalClassA = results.class_a_total || 0;
  const totalClassB = results.class_b_total || 0;
  const totalAll = totalClassA + totalClassB;
  
  // Check if minimum buffer requirement is met
  const minBufferTarget = 5.0;
  const isBufferMet = (results.min_buffer_actual || 0) >= minBufferTarget;
  
  // Prepare data for tranche comparison chart
  const classComparisonData = [
    {
      name: "Class A",
      principal: results.class_a_principal || 0,
      interest: results.class_a_interest || 0,
      total: results.class_a_total || 0,
      color: classAColor
    },
    {
      name: "Class B",
      principal: results.class_b_principal || 0,
      coupon: results.class_b_coupon || 0,
      total: results.class_b_total || 0,
      color: classBColor
    },
  ];
  
  // Prepare data for pie chart
  const pieData = [
    { name: 'Class A', value: totalClassA, color: classAColor },
    { name: 'Class B', value: totalClassB, color: classBColor }
  ];
  
  // Prepare data for tranche-level charts
  const trancheDetails = results.tranche_results ? results.tranche_results.map(t => ({
    name: t["Tranche"],
    principal: t["Principal"],
    interest: t["Is Class A"] ? t["Interest"] : t["Coupon Payment"],
    total: t["Total Payment"],
    buffer: t["Buffer Cash Flow Ratio (%)"],
    maturity: t["Maturity Days"],
    isClassA: t["Is Class A"],
    bufferIn: t["Buffer In"],
    cashFlow: t["Cash Flow Total"],
    reinvestment: t["Reinvestment Return"],
    bufferReinvestment: t["Buffer Reinvestment"],
    totalAvailable: t["Total Available"],
  })) : [];
  
  // Prepare data for timeline/maturity chart
  const maturityData = trancheDetails.map(t => ({
    ...t,
    x: t.maturity,
    y: t.total,
    z: t.isClassA ? 30 : 60, // Size for scatter plot
  }));
  
  // Prepare buffer ratio chart data
  const bufferData = trancheDetails
    .filter(t => t.isClassA)
    .map(t => ({
      name: t.name,
      buffer: t.buffer,
      minimum: minBufferTarget
    }));
    
  // Cash flow components data
  const cashFlowComponentsData = trancheDetails.map(t => ({
    name: t.name,
    cashFlow: t.cashFlow,
    reinvestment: t.reinvestment,
    bufferIn: t.bufferIn,
    bufferReinvestment: t.bufferReinvestment,
  }));
  
  // Financing cost analysis data for visualization
  const financingData = [
    { name: 'Total Loan Principal', value: results.total_loan_principal },
    { name: 'Total Principal Paid', value: results.total_principal_paid },
  ];
  
  // Color palette for multiple tranches
  const getTrancheColor = (index, isClassA) => {
    if (isClassA) {
      const colors = [
        theme.palette.primary.main,
        theme.palette.primary.light,
        alpha(theme.palette.primary.main, 0.8),
        alpha(theme.palette.primary.main, 0.6),
        alpha(theme.palette.primary.main, 0.4),
      ];
      return colors[index % colors.length];
    } else {
      const colors = [
        theme.palette.secondary.main,
        theme.palette.secondary.light,
        alpha(theme.palette.secondary.main, 0.8),
        alpha(theme.palette.secondary.main, 0.6),
        alpha(theme.palette.secondary.main, 0.4),
      ];
      return colors[index % colors.length];
    }
  };
  
  // Chart configuration
  const chartConfig = {
    height: 350,
    margin: { top: 20, right: 30, left: 20, bottom: 20 },
  };

  return (
    <Box>
      {/* Summary Section */}
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 3, 
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03),
          borderRadius: 2
        }}
      >
        <Typography variant="h6" color="primary.main" fontWeight="medium" gutterBottom>
          Calculation Results Summary
        </Typography>
        
        <Box sx={{ display: "flex", flexWrap: "wrap", gap: 3, mt: 2 }}>
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
              Payment Totals
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class A Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassA)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassA / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.primary.main, 0.1),
                          color: theme.palette.primary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Class B Total</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(totalClassB)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Chip 
                        size="small" 
                        label={formatPercent(totalAll > 0 ? (totalClassB / totalAll * 100) : 0)}
                        sx={{ 
                          bgcolor: alpha(theme.palette.secondary.main, 0.1),
                          color: theme.palette.secondary.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Grand Total</TableCell>
                    <TableCell align="right">{formatCurrency(totalAll)}</TableCell>
                    <TableCell align="right">
                      <Chip 
                        size="small" 
                        label="100.00%"
                        sx={{ 
                          bgcolor: alpha(theme.palette.info.main, 0.1),
                          color: theme.palette.info.main,
                          fontWeight: 500,
                          fontSize: '0.75rem'
                        }}
                      />
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
          
          <Box sx={{ 
            flex: "1 0 300px", 
            bgcolor: 'background.paper', 
            p: 2, 
            borderRadius: 1,
            boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
          }}>
            <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
              Principal and Interest
            </Typography>
            <TableContainer sx={{ mt: 1 }}>
              <Table size="small">
                <TableBody>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classAColor,
                            mr: 1 
                          }} 
                        />
                        Class A
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_a_interest)}</TableCell>
                  </TableRow>
                  <TableRow>
                    <TableCell sx={{ pl: 0, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Box 
                          component="span" 
                          sx={{ 
                            display: 'inline-block', 
                            width: 10, 
                            height: 10, 
                            borderRadius: '50%', 
                            bgcolor: classBColor,
                            mr: 1 
                          }} 
                        />
                        Class B
                      </Box>
                    </TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_principal)}</TableCell>
                    <TableCell align="right" sx={{ borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>{formatCurrency(results.class_b_coupon)}</TableCell>
                  </TableRow>
                  <TableRow sx={{ "& td": { fontWeight: 600 } }}>
                    <TableCell sx={{ pl: 0 }}>Total</TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}
                    </TableCell>
                    <TableCell align="right">
                      {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}
                    </TableCell>
                  </TableRow>
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
        </Box>
        
        <Divider sx={{ my: 3, opacity: 0.6 }} />
        
        <Box sx={{ 
          display: 'flex', 
          gap: 4, 
          flexWrap: 'wrap',
          backgroundColor: isBufferMet ? alpha(theme.palette.success.main, 0.08) : alpha(theme.palette.error.main, 0.08),
          p: 2,
          borderRadius: 1
        }}>
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Minimum Buffer Requirement
            </Typography>
            <Typography variant="h6" sx={{ mt: 0.5 }}>
              {formatPercent(minBufferTarget)}
            </Typography>
          </Box>
          
          <Box>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Actual Minimum Buffer (Class A)
            </Typography>
            <Typography variant="h6" color={isBufferMet ? "success.main" : "error.main"} sx={{ mt: 0.5 }}>
              {formatPercent(results.min_buffer_actual)}
            </Typography>
          </Box>
          
          <Box sx={{ ml: 'auto' }}>
            <Typography variant="body2" color="text.secondary" fontWeight={500}>
              Status
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', mt: 0.5 }}>
              {isBufferMet ? (
                <CheckCircleOutlineIcon color="success" sx={{ mr: 1 }} />
              ) : (
                <ErrorOutlineIcon color="error" sx={{ mr: 1 }} />
              )}
              <Typography 
                variant="h6" 
                color={isBufferMet ? "success.main" : "error.main"}
              >
                {isBufferMet ? "Requirement Met" : "Requirement Not Met"}
              </Typography>
            </Box>
          </Box>
        </Box>
      </Paper>
      
      {/* Chart and Table Tabs */}
      <Box sx={{ mb: 4 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 'auto',
              px: 3
            }
          }}
        >
          <Tab icon={<PieChartIcon />} label="Overview" iconPosition="start" />
          <Tab icon={<BarChartIcon />} label="Tranche Details" iconPosition="start" />
          <Tab icon={<TimelineIcon />} label="Maturity Analysis" iconPosition="start" />
          <Tab icon={<ShowChartIcon />} label="Cash Flow Analysis" iconPosition="start" />
          <Tab icon={<AccountBalanceWalletIcon />} label="Financing" iconPosition="start" />
          <Tab icon={<TableChartIcon />} label="Detailed Table" iconPosition="start" />
        </Tabs>
        
        {/* Tab 1: Overview Charts */}
        {tabValue === 0 && (
          <Grid container spacing={3}>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  height: '100%',
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Distribution by Class
                </Typography>
                <Box sx={{ height: chartConfig.height, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <PieChart margin={chartConfig.margin}>
                      <Pie
                        data={pieData}
                        dataKey="value"
                        nameKey="name"
                        cx="50%"
                        cy="50%"
                        outerRadius={100}
                        innerRadius={60}
                        labelLine={false}
                        label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
                      >
                        {pieData.map((entry, index) => (
                          <Cell key={`cell-${index}`} fill={entry.color} />
                        ))}
                      </Pie>
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                    </PieChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  height: '100%',
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Principal vs Interest/Coupon
                </Typography>
                <Box sx={{ height: chartConfig.height, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={classComparisonData}
                      margin={chartConfig.margin}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis dataKey="name" />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="principal" 
                        name="Principal" 
                        stackId="a" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="interest" 
                        name="Interest" 
                        stackId="a" 
                        fill={theme.palette.info.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="coupon" 
                        name="Coupon" 
                        stackId="a" 
                        fill={theme.palette.secondary.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 3, 
                  mb: 3, 
                  border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                  backgroundColor: alpha(theme.palette.info.main, 0.03),
                  borderRadius: 2
                }}
              >
                <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                  Financing Cost Analysis
                </Typography>
                
                <Grid container spacing={3}>
                  <Grid item xs={12} md={6}>
                    <Box sx={{ 
                      mt: 2,
                      p: 2,
                      bgcolor: 'background.paper', 
                      borderRadius: 1,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <TableContainer>
                        <Table>
                          <TableBody>
                            <TableRow>
                              <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Principal Paid to Bank:</TableCell>
                              <TableCell align="right" sx={{ fontWeight: 600, pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                                {formatCurrency(results.total_principal_paid)}
                              </TableCell>
                            </TableRow>
                            <TableRow>
                              <TableCell sx={{ pl: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>Total Loan Principal:</TableCell>
                              <TableCell align="right" sx={{ pr: 2, borderBottom: `1px solid ${alpha('#000', 0.08)}` }}>
                                {formatCurrency(results.total_loan_principal)}
                              </TableCell>
                            </TableRow>
                            <TableRow>
                              <TableCell sx={{ pl: 2, fontWeight: 600 }}>
                                Financing {(results.financing_cost || 0) > 0 ? "Profit" : "Loss"}:
                              </TableCell>
                              <TableCell 
                                align="right" 
                                sx={{ 
                                  fontWeight: 600,
                                  pr: 2,
                                  color: (results.financing_cost || 0) > 0 ? "success.main" : "error.main"
                                }}
                              >
                                {formatCurrency(Math.abs(results.financing_cost || 0))}
                              </TableCell>
                            </TableRow>
                          </TableBody>
                        </Table>
                      </TableContainer>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Box sx={{ height: 250 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={financingData}
                          margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                          layout="vertical"
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                          <XAxis type="number" tickFormatter={(value) => `â‚º${value/1000000}M`} />
                          <YAxis type="category" dataKey="name" />
                          <Tooltip 
                            content={<CustomTooltip formatter={(value) => formatCurrency(value)} />} 
                          />
                          <Bar 
                            dataKey="value" 
                            fill={(results.financing_cost || 0) > 0 ? theme.palette.success.light : theme.palette.error.light}
                            radius={4}
                            barSize={30}
                          />
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                  </Grid>
                </Grid>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 2: Tranche Details */}
        {tabValue === 1 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Tranche Payments Breakdown
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 20, right: 30, left: 20, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name" 
                        angle={-45}
                        textAnchor="end"
                        height={60}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="principal" 
                        name="Principal" 
                        fill={theme.palette.primary.dark}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="interest" 
                        name="Interest/Coupon" 
                        fill={theme.palette.secondary.light}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Individual Tranche Amounts
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Bar 
                        dataKey="total" 
                        name="Total Payment" 
                        radius={[4, 4, 0, 0]}
                      >
                        {trancheDetails.map((entry, index) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={getTrancheColor(index, entry.isClassA)} 
                          />
                        ))}
                      </Bar>
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Buffer Analysis (Class A)
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={bufferData}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `${value}%`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => `${value.toFixed(2)}%`} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="buffer" 
                        name="Buffer Ratio" 
                        fill={theme.palette.success.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="minimum" 
                        name="Minimum Requirement" 
                        fill={theme.palette.error.light}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 3: Maturity Analysis */}
        {tabValue === 2 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Maturity Distribution
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <ScatterChart
                      margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        type="number" 
                        dataKey="maturity" 
                        name="Maturity" 
                        unit=" days" 
                        domain={[0, 'dataMax + 30']}
                      />
                      <YAxis 
                        type="number" 
                        dataKey="total" 
                        name="Total Payment" 
                        tickFormatter={(value) => `â‚º${value/1000000}M`}
                      />
                      <ZAxis range={[60, 200]} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "Maturity" ? `${value} days` : formatCurrency(value)
                        } />}
                        cursor={{ strokeDasharray: '3 3' }}
                      />
                      <Legend />
                      <Scatter 
                        name="Tranche Payments" 
                        data={maturityData}
                        fill={theme.palette.primary.main}
                      >
                        {maturityData.map((entry, index) => (
                          <Cell 
                            key={`cell-${index}`} 
                            fill={getTrancheColor(index, entry.isClassA)} 
                          />
                        ))}
                      </Scatter>
                    </ScatterChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Payment Timeline
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <LineChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="maturity"
                        type="number"
                        domain={['dataMin', 'dataMax']}
                        label={{ 
                          value: 'Maturity (days)', 
                          position: 'insideBottomRight', 
                          offset: -10 
                        }}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "maturity" ? `${value} days` : formatCurrency(value)
                        } />}
                      />
                      <Legend />
                      <Line 
                        type="monotone" 
                        dataKey="total" 
                        name="Total Payment" 
                        stroke={theme.palette.primary.main}
                        strokeWidth={2}
                        dot={{ r: 6 }}
                        activeDot={{ r: 8 }}
                      />
                    </LineChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Maturity vs. Buffer Ratio
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <ScatterChart
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        type="number"
                        dataKey="maturity"
                        name="Maturity"
                        unit=" days"
                        label={{ 
                          value: 'Maturity (days)', 
                          position: 'insideBottomRight', 
                          offset: -10 
                        }}
                      />
                      <YAxis 
                        type="number"
                        dataKey="buffer"
                        name="Buffer Ratio"
                        unit="%"
                      />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value, name) => 
                          name === "Maturity" ? `${value} days` : `${value.toFixed(2)}%`
                        } />}
                      />
                      <ReferenceLine 
                        y={minBufferTarget}
                        stroke={theme.palette.error.main}
                        strokeDasharray="3 3"
                        label={{ 
                          value: 'Minimum Requirement', 
                          position: 'insideTopRight',
                          fill: theme.palette.error.main,
                          fontSize: 12
                        }}
                      />
                      <Scatter 
                        name="Class A Tranches" 
                        data={trancheDetails.filter(t => t.isClassA)}
                        fill={theme.palette.primary.main}
                      >
                        {trancheDetails
                          .filter(t => t.isClassA)
                          .map((entry, index) => (
                            <Cell 
                              key={`cell-${index}`} 
                              fill={entry.buffer >= minBufferTarget 
                                ? theme.palette.success.main
                                : theme.palette.error.main
                              } 
                            />
                        ))}
                      </Scatter>
                    </ScatterChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 4: Cash Flow Analysis */}
        {tabValue === 3 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Cash Flow Components by Tranche
                </Typography>
                <Box sx={{ height: 400, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={cashFlowComponentsData}
                      margin={{ top: 20, right: 30, left: 20, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name" 
                        angle={-45}
                        textAnchor="end"
                        height={60}
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="cashFlow" 
                        name="Cash Flow" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="reinvestment" 
                        name="Reinvestment Return" 
                        fill={theme.palette.secondary.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="bufferIn" 
                        name="Buffer In" 
                        fill={theme.palette.info.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="bufferReinvestment" 
                        name="Buffer Reinvestment" 
                        fill={theme.palette.warning.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Available vs Payment
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <BarChart
                      data={trancheDetails}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Bar 
                        dataKey="totalAvailable" 
                        name="Total Available" 
                        fill={theme.palette.success.main}
                        radius={[4, 4, 0, 0]}
                      />
                      <Bar 
                        dataKey="total" 
                        name="Total Payment" 
                        fill={theme.palette.primary.main}
                        radius={[4, 4, 0, 0]}
                      />
                    </BarChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
            
            <Grid item xs={12} md={6}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 2, 
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  borderRadius: 2
                }}
              >
                <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                  Cash Flow Components
                </Typography>
                <Box sx={{ height: 350, mt: 1 }}>
                  <ResponsiveContainer width="100%" height="100%">
                    <AreaChart
                      data={cashFlowComponentsData}
                      margin={{ top: 5, right: 30, left: 5, bottom: 60 }}
                    >
                      <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                      <XAxis 
                        dataKey="name"
                        angle={-45}
                        textAnchor="end"
                        height={60}  
                      />
                      <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                      <Tooltip 
                        content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                      />
                      <Legend />
                      <Area 
                        type="monotone" 
                        dataKey="cashFlow" 
                        name="Cash Flow" 
                        stackId="1"
                        stroke={theme.palette.primary.main}
                        fill={alpha(theme.palette.primary.main, 0.6)}
                      />
                      <Area 
                        type="monotone" 
                        dataKey="reinvestment" 
                        name="Reinvestment" 
                        stackId="1"
                        stroke={theme.palette.secondary.main}
                        fill={alpha(theme.palette.secondary.main, 0.6)}
                      />
                      <Area 
                        type="monotone" 
                        dataKey="bufferIn" 
                        name="Buffer In" 
                        stackId="1"
                        stroke={theme.palette.info.main}
                        fill={alpha(theme.palette.info.main, 0.6)}
                      />
                    </AreaChart>
                  </ResponsiveContainer>
                </Box>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 5: Financing Analysis */}
        {tabValue === 4 && (
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <Paper 
                elevation={0}
                sx={{ 
                  p: 3, 
                  border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                  backgroundColor: alpha(theme.palette.info.main, 0.03),
                  borderRadius: 2
                }}
              >
                <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                  Financing Cost Analysis
                </Typography>
                
                <Grid container spacing={4}>
                  <Grid item xs={12} md={6}>
                    <Box sx={{ 
                      p: 3,
                      bgcolor: 'background.paper', 
                      borderRadius: 2,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <Typography variant="subtitle1" gutterBottom color="text.secondary" fontWeight="medium">
                        Key Metrics
                      </Typography>
                      
                      <Box sx={{ mt: 2 }}>
                        <Grid container spacing={2}>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Total Loan Principal</Typography>
                            <Typography variant="h6" fontWeight="medium">{formatCurrency(results.total_loan_principal)}</Typography>
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Principal Paid to Bank</Typography>
                            <Typography variant="h6" fontWeight="medium">{formatCurrency(results.total_principal_paid)}</Typography>
                          </Grid>
                          <Grid item xs={12}>
                            <Divider sx={{ my: 2 }} />
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Financing Result</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={(results.financing_cost || 0) > 0 ? "success.main" : "error.main"}
                            >
                              {(results.financing_cost || 0) > 0 ? "PROFIT" : "LOSS"}
                            </Typography>
                          </Grid>
                          <Grid item xs={6}>
                            <Typography variant="body2" color="text.secondary">Amount</Typography>
                            <Typography 
                              variant="h5" 
                              fontWeight="medium"
                              color={(results.financing_cost || 0) > 0 ? "success.main" : "error.main"}
                            >
                              {formatCurrency(Math.abs(results.financing_cost || 0))}
                            </Typography>
                          </Grid>
                        </Grid>
                      </Box>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Box sx={{ height: 300 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <BarChart
                          data={financingData}
                          margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                        >
                          <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                          <XAxis dataKey="name" />
                          <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                          <Tooltip 
                            content={<CustomTooltip formatter={(value) => formatCurrency(value)} />}
                          />
                          <Legend />
                          <Bar 
                            dataKey="value" 
                            name="Amount" 
                            radius={[4, 4, 0, 0]}
                          >
                            {financingData.map((entry, index) => (
                              <Cell 
                                key={`cell-${index}`} 
                                fill={index === 0 
                                  ? theme.palette.info.main 
                                  : theme.palette.primary.main
                                } 
                              />
                            ))}
                          </Bar>
                        </BarChart>
                      </ResponsiveContainer>
                    </Box>
                  </Grid>
                  
                  <Grid item xs={12}>
                    <Box sx={{ 
                      p: 3,
                      bgcolor: 'background.paper', 
                      borderRadius: 2,
                      boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                    }}>
                      <Typography variant="subtitle1" gutterBottom fontWeight="medium">
                        Financing Analysis
                      </Typography>
                      
                      <Typography variant="body1" paragraph>
                        The total principal paid to the bank is {formatCurrency(results.total_principal_paid)}, while the total loan principal is {formatCurrency(results.total_loan_principal)}.
                      </Typography>
                      
                      {(results.financing_cost || 0) > 0 ? (
                        <Typography variant="body1" paragraph>
                          This results in a <strong>financing profit of {formatCurrency(Math.abs(results.financing_cost || 0))}</strong>, representing a positive return on the securitization structure.
                        </Typography>
                      ) : (
                        <Typography variant="body1" paragraph>
                          This results in a <strong>financing loss of {formatCurrency(Math.abs(results.financing_cost || 0))}</strong>, indicating a cost of the securitization structure.
                        </Typography>
                      )}
                      
                      <Typography variant="body1">
                        The total principal of the ABS structure (Class A + Class B) is {formatCurrency((results.class_a_principal || 0) + (results.class_b_principal || 0))}, with total interest and coupon payments of {formatCurrency((results.class_a_interest || 0) + (results.class_b_coupon || 0))}.
                      </Typography>
                    </Box>
                  </Grid>
                </Grid>
              </Paper>
            </Grid>
          </Grid>
        )}
        
        {/* Tab 6: Detailed Table */}
        {tabValue === 5 && (
          <Box>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`,
                backgroundColor: 'background.paper',
                borderRadius: 2
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Detailed Tranche Results
              </Typography>
              
              {results.tranche_results && results.tranche_results.length > 0 ? (
                <TableContainer sx={{ 
                  maxHeight: 440,
                  mt: 2,
                  borderRadius: 1,
                  boxShadow: `0 1px 3px ${alpha('#000', 0.08)}`
                }}>
                  <Table stickyHeader>
                    <TableHead>
                      <TableRow>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Tranche</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Days</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Maturity Date</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Principal</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Interest / Coupon</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Total Payment</TableCell>
                        <TableCell sx={{ fontWeight: 600, backgroundColor: alpha(theme.palette.primary.main, 0.04) }}>Buffer Ratio (%)</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {results.tranche_results.map((tranche, index) => (
                        <TableRow 
                          key={index}
                          sx={{ 
                            backgroundColor: tranche["Is Class A"] 
                              ? alpha(theme.palette.primary.main, 0.03)
                              : alpha(theme.palette.secondary.main, 0.03),
                            '&:hover': {
                              backgroundColor: tranche["Is Class A"] 
                                ? alpha(theme.palette.primary.main, 0.07)
                                : alpha(theme.palette.secondary.main, 0.07),
                            }
                          }}
                        >
                          <TableCell>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              <Box 
                                component="span" 
                                sx={{ 
                                  display: 'inline-block', 
                                  width: 10, 
                                  height: 10, 
                                  borderRadius: '50%', 
                                  bgcolor: tranche["Is Class A"] ? classAColor : classBColor,
                                  mr: 1 
                                }} 
                              />
                              {tranche["Tranche"]}
                            </Box>
                          </TableCell>
                          <TableCell>{tranche["Maturity Days"]}</TableCell>
                          <TableCell>{tranche["Maturity Date"]}</TableCell>
                          <TableCell>{formatCurrency(tranche["Principal"])}</TableCell>
                          <TableCell>
                            {formatCurrency(
                              tranche["Is Class A"] ? tranche["Interest"] : tranche["Coupon Payment"]
                            )}
                          </TableCell>
                          <TableCell>{formatCurrency(tranche["Total Payment"])}</TableCell>
                          <TableCell>
                            <Chip 
                              size="small" 
                              label={formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}
                              sx={{ 
                                bgcolor: 
                                  tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                                    ? alpha(theme.palette.success.main, 0.1)
                                    : alpha(theme.palette.warning.main, 0.1),
                                color: 
                                  tranche["Buffer Cash Flow Ratio (%)"] >= minBufferTarget
                                    ? theme.palette.success.main
                                    : theme.palette.warning.main,
                                fontWeight: 500,
                                fontSize: '0.75rem'
                              }}
                            />
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              ) : (
                <Typography variant="body2" color="text.secondary" sx={{ py: 3, textAlign: "center" }}>
                  Detailed results are not available yet
                </Typography>
              )}
            </Paper>
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default CalculationResults;

======================================================================

DOSYA: src\pages\ComparisonPage.js
==================================================
// src/pages/ComparisonPage.js
import React, { useState } from 'react';
import { 
  Container, 
  Typography, 
  Box, 
  Paper, 
  Tabs, 
  Tab, 
  Grid, 
  Card, 
  CardContent, 
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow,
  Chip,
  Divider,
  alpha,
  useTheme,
  Button,
  Menu,
  MenuItem,
  ListItemIcon,
  ListItemText,
  IconButton,
  Tooltip as MuiTooltip,
  Select,
  FormControl,
  InputLabel,
  Alert
} from '@mui/material';
import { useData } from '../contexts/DataContext';
import CompareIcon from '@mui/icons-material/Compare';
import AccountBalanceWalletIcon from '@mui/icons-material/AccountBalanceWallet';
import BarChartIcon from '@mui/icons-material/BarChart';
import PieChartIcon from '@mui/icons-material/PieChart';
import TimelineIcon from '@mui/icons-material/Timeline';
import DeleteIcon from '@mui/icons-material/Delete';
import ClearAllIcon from '@mui/icons-material/ClearAll';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import DownloadIcon from '@mui/icons-material/Download';
import { 
  BarChart, Bar, PieChart, Pie, Cell, LineChart, Line, 
  XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, 
  Area, AreaChart, ScatterChart, Scatter, ZAxis, ReferenceLine
} from "recharts";

const ComparisonPage = () => {
  const theme = useTheme();
  const { 
    calculationResults, 
    previousCalculationResults, 
    multipleComparisonResults,
    setMultipleComparisonResults
  } = useData();
  
  const [tabValue, setTabValue] = useState(0);
  const [selectedResults, setSelectedResults] = useState(['current', 'previous']);
  const [menuAnchorEl, setMenuAnchorEl] = useState(null);
  
  // Handle tab change
  const handleTabChange = (event, newValue) => {
    setTabValue(newValue);
  };
  
  // Handle menu open/close
  const handleMenuOpen = (event) => {
    setMenuAnchorEl(event.currentTarget);
  };
  
  const handleMenuClose = () => {
    setMenuAnchorEl(null);
  };
  
  // Handle clear all results
  const handleClearAll = () => {
    if (window.confirm('Are you sure you want to clear all comparison results?')) {
      setMultipleComparisonResults([]);
      handleMenuClose();
    }
  };
  
  // Handle selection change
  const handleSelectionChange = (event, resultId) => {
    const selectedValue = event.target.value;
    
    if (selectedValue) {
      const newSelected = [...selectedResults];
      const index = newSelected.indexOf(resultId);
      
      if (index !== -1) {
        newSelected[index] = selectedValue;
        setSelectedResults(newSelected);
      }
    }
  };
  
  // Handle delete result
  const handleDeleteResult = (index) => {
    const newResults = [...multipleComparisonResults];
    newResults.splice(index, 1);
    setMultipleComparisonResults(newResults);
    
    // Update selected results if necessary
    const newSelected = selectedResults.map(sel => {
      if (sel.startsWith('multi-') && parseInt(sel.split('-')[1]) === index) {
        return 'current';
      } else if (sel.startsWith('multi-') && parseInt(sel.split('-')[1]) > index) {
        return `multi-${parseInt(sel.split('-')[1]) - 1}`;
      }
      return sel;
    });
    
    setSelectedResults(newSelected);
  };

  // Format currency values
  const formatCurrency = (value) => {
    if (value === undefined || value === null) return "â‚º0.00";
    return new Intl.NumberFormat("tr-TR", { style: "currency", currency: "TRY" }).format(value);
  };
  
  // Format percentage values
  const formatPercent = (value) => {
    if (value === undefined || value === null) return "0.00%";
    return `${value.toFixed(2)}%`;
  };

  // Calculate percentage difference
  const calculateDifference = (current, previous) => {
    if (!current || !previous || previous === 0) return null;
    return ((current - previous) / previous) * 100;
  };

  // Format difference with color and sign
  const formatDifference = (diff) => {
    if (diff === null) return "-";
    const isPositive = diff > 0;
    return (
      <Typography 
        variant="body2" 
        sx={{ 
          color: isPositive ? 'success.main' : 'error.main',
          fontWeight: 'medium',
          display: 'flex',
          alignItems: 'center'
        }}
      >
        {isPositive ? '+' : ''}{diff.toFixed(2)}%
      </Typography>
    );
  };
  
  // Get results by selection ID
  const getResultsById = (id) => {
    if (id === 'current') {
      return calculationResults;
    } else if (id === 'previous') {
      return previousCalculationResults;
    } else if (id.startsWith('multi-')) {
      const index = parseInt(id.split('-')[1]);
      return multipleComparisonResults[index];
    }
    return null;
  };
  
  // Check for any selection
  const hasValidSelection = () => {
    return selectedResults.some(id => getResultsById(id) !== null);
  };
  
  // Get comparison results
  const getComparisonResults = () => {
    return selectedResults.map(id => {
      const result = getResultsById(id);
      if (!result) return null;
      
      let label = '';
      if (id === 'current') {
        label = result.is_optimized 
          ? `Current (${result.optimization_method || 'Optimized'})` 
          : 'Current (Manual)';
      } else if (id === 'previous') {
        label = 'Previous';
      } else if (id.startsWith('multi-')) {
        const index = parseInt(id.split('-')[1]);
        label = multipleComparisonResults[index]?.label || `Result ${index + 1}`;
      }
      
      return {
        id,
        label,
        result,
        isOptimized: result.is_optimized,
        method: result.optimization_method,
        color: id === 'current' 
          ? theme.palette.primary.main 
          : id === 'previous'
            ? theme.palette.secondary.main
            : theme.palette.info.main
      };
    }).filter(item => item !== null);
  };

  // No comparison data available, show guidance
  if (!hasValidSelection()) {
    return (
      <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
        <Paper 
          elevation={0}
          sx={{ 
            p: 4, 
            textAlign: 'center',
            borderRadius: 2,
            backgroundColor: alpha(theme.palette.info.main, 0.05),
            border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`
          }}
        >
          <CompareIcon sx={{ fontSize: 60, color: theme.palette.info.main, opacity: 0.7, mb: 2 }} />
          <Typography variant="h5" gutterBottom>
            Comparison Data Not Available
          </Typography>
          <Typography variant="body1" color="text.secondary">
            To compare results, first calculate your initial structure, then apply an optimization result and calculate again.
          </Typography>
          <Box sx={{ mt: 4 }}>
            <Grid container spacing={3} justifyContent="center">
              <Grid item xs={12} md={6}>
                <Card variant="outlined" sx={{ height: '100%' }}>
                  <CardContent>
                    <Typography variant="subtitle1" gutterBottom color="primary" fontWeight="medium">
                      How to Compare
                    </Typography>
                    <ol>
                      <li>Go to the Calculation page and set up your initial parameters</li>
                      <li>Calculate the results for your manual configuration</li>
                      <li>Go to the Optimization page and run an optimization</li>
                      <li>Apply the optimized configuration and see the calculated results</li>
                      <li>Return to this page to see a detailed comparison</li>
                    </ol>
                  </CardContent>
                </Card>
              </Grid>
            </Grid>
          </Box>
        </Paper>
      </Container>
    );
  }
  
  // Get active comparison results
  const comparisonResults = getComparisonResults();
  
  // Prepare chart data
  const barChartData = comparisonResults.map(item => ({
    name: item.label,
    classA: item.result.class_a_total || 0,
    classB: item.result.class_b_total || 0,
    total: (item.result.class_a_total || 0) + (item.result.class_b_total || 0),
    color: item.color
  }));
  
  // Prepare principal interest breakdown data
  const breakdownData = comparisonResults.map(item => ({
    name: item.label,
    classAPrincipal: item.result.class_a_principal || 0,
    classAInterest: item.result.class_a_interest || 0,
    classBPrincipal: item.result.class_b_principal || 0,
    classBCoupon: item.result.class_b_coupon || 0,
    color: item.color
  }));
  
  // Prepare buffer data
  const bufferData = comparisonResults.map(item => ({
    name: item.label,
    minBuffer: item.result.min_buffer_actual || 0,
    color: item.color
  }));
  
  // Prepare financing data
  const financingData = comparisonResults.map(item => ({
    name: item.label,
    financingCost: Math.abs(item.result.financing_cost || 0),
    isProfit: (item.result.financing_cost || 0) > 0,
    principalPaid: item.result.total_principal_paid || 0,
    loanPrincipal: item.result.total_loan_principal || 0,
    color: item.color
  }));
  
  // Helper function for custom tooltip
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      return (
        <Paper sx={{ p: 1.5, borderRadius: 1, boxShadow: 2 }}>
          <Typography variant="body2" fontWeight="medium">{label}</Typography>
          {payload.map((entry, index) => (
            <Box key={`tooltip-${index}`} sx={{ display: 'flex', justifyContent: 'space-between', mt: 0.5 }}>
              <Typography variant="body2" sx={{ mr: 2, color: entry.color }}>
                {entry.name}:
              </Typography>
              <Typography variant="body2" fontWeight="medium">
                {entry.name.includes('Buffer') 
                  ? `${entry.value.toFixed(2)}%` 
                  : formatCurrency(entry.value)}
              </Typography>
            </Box>
          ))}
        </Paper>
      );
    }
    return null;
  };
  
  // Get all available results for selection dropdown
  const getAvailableResults = () => {
    const options = [];
    
    if (calculationResults) {
      options.push({ id: 'current', label: calculationResults.is_optimized 
        ? `Current (${calculationResults.optimization_method || 'Optimized'})` 
        : 'Current (Manual)' });
    }
    
    if (previousCalculationResults) {
      options.push({ id: 'previous', label: 'Previous' });
    }
    
    if (multipleComparisonResults && multipleComparisonResults.length > 0) {
      multipleComparisonResults.forEach((result, index) => {
        options.push({ 
          id: `multi-${index}`, 
          label: result.label || `Result ${index + 1}` 
        });
      });
    }
    
    return options;
  };

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 3 }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <CompareIcon sx={{ fontSize: 28, color: theme.palette.primary.main, mr: 2 }} />
          <Typography variant="h4" component="h1" gutterBottom>
            Results Comparison
          </Typography>
        </Box>
        
        <IconButton onClick={handleMenuOpen}>
          <MoreVertIcon />
        </IconButton>
        
        <Menu
          anchorEl={menuAnchorEl}
          open={Boolean(menuAnchorEl)}
          onClose={handleMenuClose}
        >
          <MenuItem onClick={handleClearAll}>
            <ListItemIcon>
              <ClearAllIcon fontSize="small" />
            </ListItemIcon>
            <ListItemText>Clear All Comparison Results</ListItemText>
          </MenuItem>
          <MenuItem onClick={handleMenuClose}>
            <ListItemIcon>
              <DownloadIcon fontSize="small" />
            </ListItemIcon>
            <ListItemText>Export Comparison</ListItemText>
          </MenuItem>
        </Menu>
      </Box>
      
      {/* Select comparison results */}
      <Paper sx={{ p: 3, mb: 4, borderRadius: 2 }}>
        <Typography variant="h6" gutterBottom>
          Select Results to Compare
        </Typography>
        
        <Grid container spacing={3}>
          {selectedResults.map((resultId, index) => (
            <Grid item xs={12} md={6} key={index}>
              <FormControl fullWidth>
                <InputLabel id={`select-result-${index}-label`}>Result {index + 1}</InputLabel>
                <Select
                  labelId={`select-result-${index}-label`}
                  value={resultId}
                  label={`Result ${index + 1}`}
                  onChange={(e) => handleSelectionChange(e, resultId)}
                >
                  {getAvailableResults().map(option => (
                    <MenuItem key={option.id} value={option.id}>{option.label}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
          ))}
        </Grid>
        
        {multipleComparisonResults && multipleComparisonResults.length > 0 && (
          <Box sx={{ mt: 3 }}>
            <Typography variant="subtitle2" gutterBottom>
              Saved Comparison Results
            </Typography>
            <TableContainer>
              <Table size="small">
                <TableHead>
                  <TableRow>
                    <TableCell>Name</TableCell>
                    <TableCell>Type</TableCell>
                    <TableCell>Date</TableCell>
                    <TableCell>Actions</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {multipleComparisonResults.map((result, index) => (
                    <TableRow key={index}>
                      <TableCell>{result.label || `Result ${index + 1}`}</TableCell>
                      <TableCell>
                        {result.is_optimized ? (
                          <Chip 
                            size="small" 
                            label={result.optimization_method || "Optimized"} 
                            color="secondary"
                          />
                        ) : (
                          <Chip size="small" label="Manual" color="primary" />
                        )}
                      </TableCell>
                      <TableCell>
                        {new Date(result.timestamp || Date.now()).toLocaleDateString()}
                      </TableCell>
                      <TableCell>
                        <MuiTooltip title="Delete">
                          <IconButton 
                            size="small" 
                            color="error" 
                            onClick={() => handleDeleteResult(index)}
                          >
                            <DeleteIcon fontSize="small" />
                          </IconButton>
                        </MuiTooltip>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          </Box>
        )}
      </Paper>
      
      <Paper 
        elevation={0}
        sx={{ 
          p: 3, 
          mb: 4, 
          borderRadius: 2,
          border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
          backgroundColor: alpha(theme.palette.primary.main, 0.03)
        }}
      >
        <Typography variant="h6" color="primary.main" gutterBottom fontWeight="medium">
          Comparison Summary
        </Typography>
        
        <Grid container spacing={3}>
          {comparisonResults.map((item, index) => (
            <Grid item xs={12} md={4} key={index}>
              <Card elevation={0} sx={{ height: '100%', backgroundColor: 'transparent', border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}` }}>
                <CardContent>
                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                    <Box 
                      sx={{ 
                        width: 12, 
                        height: 12, 
                        borderRadius: '50%', 
                        backgroundColor: item.color,
                        mr: 1
                      }} 
                    />
                    <Typography variant="subtitle1" fontWeight="medium" color="text.primary">
                      {item.label}
                    </Typography>
                  </Box>
                  
                  <Box>
                    <Typography variant="body2" color="text.secondary">Total Structure Size</Typography>
                    <Typography variant="h6">
                      {formatCurrency((item.result.class_a_total || 0) + (item.result.class_b_total || 0))}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="body2" color="text.secondary">Minimum Buffer</Typography>
                    <Typography variant="h6" color={
                      (item.result.min_buffer_actual || 0) >= 5.0 ? 'success.main' : 'error.main'
                    }>
                      {formatPercent(item.result.min_buffer_actual || 0)}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ mt: 2 }}>
                    <Typography variant="body2" color="text.secondary">Financing Result</Typography>
                    <Typography variant="h6" color={
                      (item.result.financing_cost || 0) > 0 ? 'success.main' : 'error.main'
                    }>
                      {(item.result.financing_cost || 0) > 0 ? "Profit: " : "Loss: "}
                      {formatCurrency(Math.abs(item.result.financing_cost || 0))}
                    </Typography>
                  </Box>
                </CardContent>
              </Card>
            </Grid>
          ))}
        </Grid>
      </Paper>
      
      {/* Tabs for different comparison views */}
      <Box sx={{ mb: 3 }}>
        <Tabs 
          value={tabValue} 
          onChange={handleTabChange}
          variant="scrollable"
          scrollButtons="auto"
          sx={{
            mb: 2,
            '& .MuiTab-root': {
              minWidth: 'auto',
              px: 3
            }
          }}
        >
          <Tab icon={<PieChartIcon />} label="Structure Comparison" iconPosition="start" />
          <Tab icon={<BarChartIcon />} label="Tranches Breakdown" iconPosition="start" />
          <Tab icon={<AccountBalanceWalletIcon />} label="Financing Comparison" iconPosition="start" />
          <Tab icon={<TimelineIcon />} label="Buffer Analysis" iconPosition="start" />
        </Tabs>
      </Box>
      
      {/* Tab 1: Structure Comparison */}
      {tabValue === 0 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Total Structure Comparison
              </Typography>
              
              <Box sx={{ height: 400, mt: 2 }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={barChartData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                    <XAxis dataKey="name" />
                    <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Bar 
                      dataKey="classA" 
                      name="Class A" 
                      stackId="a"
                      fill={theme.palette.primary.main} 
                    />
                    <Bar 
                      dataKey="classB" 
                      name="Class B" 
                      stackId="a"
                      fill={theme.palette.secondary.main} 
                    />
                  </BarChart>
                </ResponsiveContainer>
              </Box>
              
              <Divider sx={{ my: 3 }} />
              
              <Typography variant="subtitle1" gutterBottom>
                Class Distribution
              </Typography>
              
              <Grid container spacing={4}>
                {comparisonResults.map((item, index) => (
                  <Grid item xs={12} md={6} key={index}>
                    <Typography variant="subtitle2" align="center" gutterBottom>
                      {item.label}
                    </Typography>
                    <Box sx={{ height: 300 }}>
                      <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                          <Pie
                            data={[
                              { name: 'Class A', value: item.result.class_a_total || 0 },
                              { name: 'Class B', value: item.result.class_b_total || 0 }
                            ]}
                            cx="50%"
                            cy="50%"
                            outerRadius={100}
                            dataKey="value"
                            label={({ name, percent }) => `${name} (${(percent * 100).toFixed(1)}%)`}
                          >
                            <Cell fill={theme.palette.primary.main} />
                            <Cell fill={theme.palette.secondary.main} />
                          </Pie>
                          <Tooltip formatter={(value) => formatCurrency(value)} />
                        </PieChart>
                      </ResponsiveContainer>
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 2: Tranches Breakdown */}
      {tabValue === 1 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.text.primary, 0.1)}`
              }}
            >
              <Typography variant="h6" gutterBottom fontWeight="medium">
                Principal & Interest Breakdown
              </Typography>
              
              <Box sx={{ height: 400, mt: 2 }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={breakdownData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                    <XAxis dataKey="name" />
                    <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Bar dataKey="classAPrincipal" name="Class A Principal" stackId="a" fill={theme.palette.primary.dark} />
                    <Bar dataKey="classAInterest" name="Class A Interest" stackId="a" fill={theme.palette.primary.light} />
                    <Bar dataKey="classBPrincipal" name="Class B Principal" stackId="b" fill={theme.palette.secondary.dark} />
                    <Bar dataKey="classBCoupon" name="Class B Coupon" stackId="b" fill={theme.palette.secondary.light} />
                  </BarChart>
                </ResponsiveContainer>
              </Box>
              
              <Divider sx={{ my: 3 }} />
              
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Metric</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">{item.label}</TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">Difference</TableCell>
                      )}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    <TableRow>
                      <TableCell>Class A Principal</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.class_a_principal || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.class_a_principal,
                            comparisonResults[1].result.class_a_principal
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow>
                      <TableCell>Class A Interest</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.class_a_interest || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.class_a_interest,
                            comparisonResults[1].result.class_a_interest
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow>
                      <TableCell>Class B Principal</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.class_b_principal || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.class_b_principal,
                            comparisonResults[1].result.class_b_principal
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow>
                      <TableCell>Class B Coupon</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.class_b_coupon || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.class_b_coupon,
                            comparisonResults[1].result.class_b_coupon
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow sx={{ "& td": { fontWeight: 'medium', backgroundColor: alpha(theme.palette.primary.main, 0.05) } }}>
                      <TableCell>Total</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(
                            (item.result.class_a_total || 0) + (item.result.class_b_total || 0)
                          )}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            (comparisonResults[0].result.class_a_total || 0) + (comparisonResults[0].result.class_b_total || 0),
                            (comparisonResults[1].result.class_a_total || 0) + (comparisonResults[1].result.class_b_total || 0)
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 3: Financing Comparison */}
      {tabValue === 2 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.info.main, 0.2)}`,
                backgroundColor: alpha(theme.palette.info.main, 0.03)
              }}
            >
              <Typography variant="h6" color="info.main" gutterBottom fontWeight="medium">
                Financing Comparison
              </Typography>
              
              <Grid container spacing={4}>
                <Grid item xs={12} md={7}>
                  <Box sx={{ height: 350 }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart
                        data={financingData}
                        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                        layout="vertical"
                      >
                        <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                        <XAxis type="number" tickFormatter={(value) => `â‚º${value/1000000}M`} />
                        <YAxis type="category" dataKey="name" />
                        <Tooltip content={<CustomTooltip />} />
                        <Legend />
                        <Bar 
                          dataKey="principalPaid" 
                          name="Total Principal Paid" 
                          fill={theme.palette.primary.main} 
                        />
                        <Bar 
                          dataKey="loanPrincipal" 
                          name="Total Loan Principal" 
                          fill={theme.palette.info.main} 
                        />
                      </BarChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
                
                <Grid item xs={12} md={5}>
                  <Box sx={{ height: 350 }}>
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart
                        data={financingData}
                        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                      >
                        <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                        <XAxis dataKey="name" />
                        <YAxis tickFormatter={(value) => `â‚º${value/1000000}M`} />
                        <Tooltip content={<CustomTooltip />} />
                        <Legend />
                        <Bar 
                          dataKey="financingCost" 
                          name="Financing Result" 
                          radius={[4, 4, 0, 0]}
                        >
                          {financingData.map((entry, index) => (
                            <Cell 
                              key={`cell-${index}`} 
                              fill={entry.isProfit ? theme.palette.success.main : theme.palette.error.main}
                            />
                          ))}
                        </Bar>
                      </BarChart>
                    </ResponsiveContainer>
                  </Box>
                </Grid>
              </Grid>
              
              <Divider sx={{ my: 3 }} />
              
              <TableContainer>
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Metric</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">{item.label}</TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">Difference</TableCell>
                      )}
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    <TableRow>
                      <TableCell>Total Principal Paid</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.total_principal_paid || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.total_principal_paid,
                            comparisonResults[1].result.total_principal_paid
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow>
                      <TableCell>Total Loan Principal</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell key={index} align="right">
                          {formatCurrency(item.result.total_loan_principal || 0)}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            comparisonResults[0].result.total_loan_principal,
                            comparisonResults[1].result.total_loan_principal
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                    <TableRow sx={{ 
                      "& td": { 
                        fontWeight: 'medium', 
                        backgroundColor: alpha(theme.palette.info.main, 0.05) 
                      } 
                    }}>
                      <TableCell>Financing Result</TableCell>
                      {comparisonResults.map((item, index) => (
                        <TableCell 
                          key={index} 
                          align="right"
                          sx={{ 
                            color: (item.result.financing_cost || 0) > 0 
                              ? 'success.main' 
                              : 'error.main' 
                          }}
                        >
                          {(item.result.financing_cost || 0) > 0 ? "Profit: " : "Loss: "}
                          {formatCurrency(Math.abs(item.result.financing_cost || 0))}
                        </TableCell>
                      ))}
                      {comparisonResults.length > 1 && (
                        <TableCell align="right">
                          {formatDifference(calculateDifference(
                            Math.abs(comparisonResults[0].result.financing_cost || 0),
                            Math.abs(comparisonResults[1].result.financing_cost || 0)
                          ))}
                        </TableCell>
                      )}
                    </TableRow>
                  </TableBody>
                </Table>
              </TableContainer>
            </Paper>
          </Grid>
        </Grid>
      )}
      
      {/* Tab 4: Buffer Analysis */}
      {tabValue === 3 && (
        <Grid container spacing={4}>
          <Grid item xs={12}>
            <Paper 
              elevation={0}
              sx={{ 
                p: 3, 
                mb: 3, 
                borderRadius: 2,
                border: `1px solid ${alpha(theme.palette.success.main, 0.2)}`,
                backgroundColor: alpha(theme.palette.success.main, 0.03)
              }}
            >
              <Typography variant="h6" color="success.main" gutterBottom fontWeight="medium">
                Buffer Analysis
              </Typography>
              
              <Box sx={{ mb: 3 }}>
                <Alert 
                  severity="info" 
                  sx={{ mb: 2 }}
                >
                  Minimum buffer requirement is 5.0%. Values below this threshold may result in cash flow issues.
                </Alert>
              </Box>
              
              <Box sx={{ height: 400, mt: 2 }}>
                <ResponsiveContainer width="100%" height="100%">
                  <BarChart
                    data={bufferData}
                    margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" stroke={alpha('#000', 0.07)} />
                    <XAxis dataKey="name" />
                    <YAxis tickFormatter={(value) => `${value}%`} domain={[0, 'dataMax + 2']} />
                    <Tooltip formatter={(value) => `${value.toFixed(2)}%`} />
                    <Legend />
                    <ReferenceLine 
                      y={5} 
                      label="Min Requirement" 
                      stroke="red" 
                      strokeDasharray="3 3" 
                    />
                    <Bar dataKey="minBuffer" name="Minimum Buffer" radius={[4, 4, 0, 0]}>
                      {bufferData.map((entry, index) => (
                        <Cell 
                          key={`cell-${index}`} 
                          fill={entry.minBuffer >= 5.0 ? theme.palette.success.main : theme.palette.error.main} 
                        />
                      ))}
                    </Bar>
                  </BarChart>
                </ResponsiveContainer>
              </Box>
              
              <Divider sx={{ my: 3 }} />
              
              <Typography variant="h6" gutterBottom>
                Buffer Details by Tranche
              </Typography>
              
              {comparisonResults.map((resultItem, resultIndex) => (
                <Box key={resultIndex} sx={{ mb: 4 }}>
                  <Typography variant="subtitle1" gutterBottom sx={{ 
                    display: 'flex',
                    alignItems: 'center',
                    color: resultItem.color
                  }}>
                    <Box 
                      sx={{ 
                        width: 12, 
                        height: 12, 
                        borderRadius: '50%', 
                        backgroundColor: resultItem.color,
                        mr: 1 
                      }} 
                    />
                    {resultItem.label}
                  </Typography>
                  
                  {resultItem.result.tranche_results ? (
                    <TableContainer sx={{ mb: 2 }}>
                      <Table size="small">
                        <TableHead>
                          <TableRow>
                            <TableCell>Tranche</TableCell>
                            <TableCell align="right">Maturity Days</TableCell>
                            <TableCell align="right">Total Payment</TableCell>
                            <TableCell align="right">Buffer Ratio (%)</TableCell>
                            <TableCell align="right">Status</TableCell>
                          </TableRow>
                        </TableHead>
                        <TableBody>
                          {resultItem.result.tranche_results
                            .filter(tranche => tranche["Is Class A"])
                            .map((tranche, index) => (
                              <TableRow key={index}>
                                <TableCell>{tranche["Tranche"]}</TableCell>
                                <TableCell align="right">{tranche["Maturity Days"]}</TableCell>
                                <TableCell align="right">{formatCurrency(tranche["Total Payment"])}</TableCell>
                                <TableCell align="right">{formatPercent(tranche["Buffer Cash Flow Ratio (%)"])}</TableCell>
                                <TableCell align="right">
                                  <Chip 
                                    size="small" 
                                    label={tranche["Buffer Cash Flow Ratio (%)"] >= 5.0 ? "OK" : "Low"} 
                                    color={tranche["Buffer Cash Flow Ratio (%)"] >= 5.0 ? "success" : "error"} 
                                  />
                                </TableCell>
                              </TableRow>
                            ))}
                        </TableBody>
                      </Table>
                    </TableContainer>
                  ) : (
                    <Typography variant="body2" color="text.secondary">
                      Detailed tranche data not available for this result.
                    </Typography>
                  )}
                </Box>
              ))}
            </Paper>
          </Grid>
        </Grid>
      )}
    </Container>
  );
};

export default ComparisonPage;

======================================================================

DOSYA: src\pages\HomePage.js
==================================================
// frontend/src/pages/HomePage.js
import React from 'react';
import { Link } from 'react-router-dom';
import { 
  Container, 
  Typography, 
  Box, 
  Button, 
  Grid, 
  Paper, 
  alpha,
  Divider 
} from '@mui/material';
import CalculateIcon from '@mui/icons-material/Calculate';
import OptimizeIcon from '@mui/icons-material/Speed';
import UploadFileIcon from '@mui/icons-material/UploadFile';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import { useTheme } from '@mui/material/styles';
import { useData } from '../contexts/DataContext';
import FileUploader from '../components/FileUploader';

const HomePage = () => {
  const { cashFlowData } = useData();
  const theme = useTheme();

  return (
    <Container maxWidth="lg" sx={{ mt: 4, mb: 4 }}>
      <Box
        sx={{
          py: 6,
          px: { xs: 3, md: 6 },
          mb: 5,
          textAlign: 'center',
          background: `linear-gradient(135deg, ${theme.palette.primary.main}, ${theme.palette.primary.dark})`,
          borderRadius: 3,
          color: 'white',
          boxShadow: `0 4px 20px ${alpha(theme.palette.primary.main, 0.3)}`,
        }}
      >
        <Typography variant="h3" component="h1" gutterBottom fontWeight="500">
          ABS Analysis Tool
        </Typography>
        <Typography variant="h6" sx={{ mb: 3, fontWeight: 400, opacity: 0.9 }}>
          Comprehensive cash flow analysis and optimization for asset-backed securities
        </Typography>
        <Divider sx={{ 
          width: '80px', 
          mx: 'auto', 
          mb: 3, 
          borderColor: 'rgba(255,255,255,0.3)' 
        }} />
        <Typography variant="body1" sx={{ maxWidth: '800px', mx: 'auto', opacity: 0.8 }}>
          Upload your Excel data file to begin analyzing your cash flows, 
          calculate securitization structures, and optimize your tranches for maximum returns.
        </Typography>
      </Box>

      <Grid container spacing={4}>
        <Grid item xs={12}>
          <Paper
            elevation={0}
            sx={{
              p: 4,
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              borderRadius: 2,
              border: `1px solid ${alpha(theme.palette.primary.main, 0.2)}`,
              backgroundColor: alpha(theme.palette.primary.main, 0.02),
            }}
          >
            <Typography variant="h5" gutterBottom fontWeight="medium" sx={{ mb: 3 }}>
              Upload Your Cash Flow Data
            </Typography>
            <FileUploader />
          </Paper>
        </Grid>

        {cashFlowData && (
          <>
            <Grid item xs={12} md={6}>
              <Paper
                elevation={0}
                sx={{
                  p: 4,
                  display: 'flex',
                  flexDirection: 'column',
                  height: '100%',
                  borderRadius: 2,
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  transition: 'all 0.3s',
                  '&:hover': {
                    transform: 'translateY(-4px)',
                    boxShadow: `0 6px 20px ${alpha(theme.palette.primary.main, 0.15)}`,
                    borderColor: alpha(theme.palette.primary.main, 0.3),
                  },
                }}
              >
                <Box sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2.5
                }}>
                  <Box sx={{ 
                    backgroundColor: alpha(theme.palette.primary.main, 0.1), 
                    borderRadius: '50%', 
                    p: 1.5, 
                    mr: 2 
                  }}>
                    <CalculateIcon sx={{ fontSize: 30, color: theme.palette.primary.main }} />
                  </Box>
                  <Typography variant="h5" fontWeight="medium" color="primary.main">
                    Calculate Results
                  </Typography>
                </Box>
                
                <Typography paragraph sx={{ color: 'text.secondary', mb: 3 }}>
                  Configure tranche parameters and calculate detailed results for your
                  ABS structure. Analyze cash flows, interest rates, and buffer ratios to
                  ensure your securitization meets all requirements.
                </Typography>
                
                <Box sx={{ mt: 'auto', textAlign: 'center' }}>
                  <Button
                    variant="contained"
                    color="primary"
                    component={Link}
                    to="/calculation"
                    size="large"
                    endIcon={<ArrowForwardIcon />}
                    sx={{ 
                      mt: 2, 
                      py: 1, 
                      px: 3,
                      fontWeight: 500,
                      borderRadius: 2,
                    }}
                  >
                    Start Calculation
                  </Button>
                </Box>
              </Paper>
            </Grid>

            <Grid item xs={12} md={6}>
              <Paper
                elevation={0}
                sx={{
                  p: 4,
                  display: 'flex',
                  flexDirection: 'column',
                  height: '100%',
                  borderRadius: 2,
                  border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
                  transition: 'all 0.3s',
                  '&:hover': {
                    transform: 'translateY(-4px)',
                    boxShadow: `0 6px 20px ${alpha(theme.palette.secondary.main, 0.15)}`,
                    borderColor: alpha(theme.palette.secondary.main, 0.3),
                  },
                }}
              >
                <Box sx={{ 
                  display: 'flex', 
                  alignItems: 'center', 
                  mb: 2.5
                }}>
                  <Box sx={{ 
                    backgroundColor: alpha(theme.palette.secondary.main, 0.1), 
                    borderRadius: '50%', 
                    p: 1.5, 
                    mr: 2 
                  }}>
                    <OptimizeIcon sx={{ fontSize: 30, color: theme.palette.secondary.main }} />
                  </Box>
                  <Typography variant="h5" fontWeight="medium" color="secondary.main">
                    Optimize Structure
                  </Typography>
                </Box>
                
                <Typography paragraph sx={{ color: 'text.secondary', mb: 3 }}>
                  Find the optimal ABS structure to maximize total principal
                  while maintaining minimum buffer requirements. Our advanced optimization
                  algorithms explore multiple strategies to find the best tranche configuration.
                </Typography>
                
                <Box sx={{ mt: 'auto', textAlign: 'center' }}>
                  <Button
                    variant="contained"
                    color="secondary"
                    component={Link}
                    to="/optimization"
                    size="large"
                    endIcon={<ArrowForwardIcon />}
                    sx={{ 
                      mt: 2, 
                      py: 1, 
                      px: 3,
                      fontWeight: 500,
                      borderRadius: 2
                    }}
                  >
                    Run Optimization
                  </Button>
                </Box>
              </Paper>
            </Grid>
          </>
        )}
      </Grid>
    </Container>
  );
};

export default HomePage;

======================================================================

DOSYA: src\pages\OptimizationPage.js
==================================================
// frontend/src/pages/OptimizationPage.js
import React, { useState, useEffect } from 'react';
import { 
  Container, Typography, Box, Paper, Button, Alert, CircularProgress,
  Grid, Divider, alpha, Chip, Stepper, Step, StepLabel, useTheme
} from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import SettingsIcon from '@mui/icons-material/Settings';
import SpeedIcon from '@mui/icons-material/Speed';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import RestartAltIcon from '@mui/icons-material/RestartAlt';
import OptimizationSettingsForm from '../components/optimization/OptimizationSettingsForm';
import OptimizationResults from '../components/optimization/OptimizationResults';
import OptimizationProgress from '../components/optimization/OptimizationProgress';
import { useData } from '../contexts/DataContext';
import { optimizeStructure } from '../services/apiService';

const OptimizationPage = () => {
  const theme = useTheme();
  const { 
    cashFlowData, 
    optimizationResults, 
    setOptimizationResults, 
    isLoading, 
    setIsLoading, 
    error, 
    setError,
    optimizationSettings,
    setOptimizationSettings,
    generalSettings
  } = useData();
  
  // Additional state to control progress component
  const [isOptimizing, setIsOptimizing] = useState(false);
  const [activeStep, setActiveStep] = useState(0);

  // Method translation mapping
  const getOptimizationMethodName = (method) => {
    const methods = {
      'classic': 'Standard Optimization',
      'genetic': 'Evolutionary Algorithm'
    };
    return methods[method] || method;
  };
  
  const handleFormChange = (values) => {
    setOptimizationSettings(values);
  };

  const handleOptimize = async () => {
    if (!cashFlowData) return;
    
    try {
      setIsLoading(true);
      setError(null);
      setIsOptimizing(true); // Start progress tracking
      setOptimizationResults(null); // Clear previous results
      setActiveStep(1); // Move to progress step
      
      // Selected optimization method
      const method = optimizationSettings.optimization_method;
      console.log(`Starting ${method} optimization...`);
      
      // Prepare request parameters
      const params = {
        optimization_settings: optimizationSettings,
        general_settings: {
          start_date: generalSettings.start_date.toISOString().split('T')[0],
          operational_expenses: generalSettings.operational_expenses,
          min_buffer: generalSettings.min_buffer
        }
      };
      
      // Log the selected strategies
      if (method === 'classic' && optimizationSettings.selected_strategies) {
        console.log(`Selected strategies: ${optimizationSettings.selected_strategies.join(', ')}`);
      }
      
      // API call based on method
      try {
        const results = await optimizeStructure(params, method);
        console.log("Optimization successful:", results);
        setOptimizationResults(results);
        setActiveStep(2); // Move to results step
      } catch (optimizeError) {
        console.error("Optimization error details:", optimizeError);
        throw new Error(`Optimization failed: ${optimizeError.message}`);
      }
    } catch (error) {
      setError('Optimization failed. Please check your parameters and try again. Error: ' + error.message);
      console.error('Optimization error:', error);
      setIsOptimizing(false); // Make sure to stop progress tracking on error
      setActiveStep(0); // Return to settings step
    } finally {
      setIsLoading(false);
      // Keep isOptimizing true until the progress component handles the completion
    }
  };
  
  // Handle optimization completion
  const handleOptimizationComplete = () => {
    setIsOptimizing(false);
  };

  // New function to handle reset
  const handleReset = () => {
    setOptimizationResults(null);
    setIsOptimizing(false);
    setActiveStep(0);
    setError(null);
    
    // Optional: Reset to default settings
    // setOptimizationSettings({...default settings});
    
    window.scrollTo(0, 0); // Scroll to top for better UX
  };

  // Effect to update active step based on results
  useEffect(() => {
    if (optimizationResults && !isOptimizing) {
      setActiveStep(2);
    }
  }, [optimizationResults, isOptimizing]);

  if (!cashFlowData) {
    return (
      <Container maxWidth="lg" sx={{ mt: 6, mb: 8 }}>
        <Paper
          elevation={0}
          sx={{
            p: 4,
            textAlign: 'center',
            borderRadius: 2,
            border: `1px solid ${alpha(theme.palette.warning.main, 0.3)}`,
            backgroundColor: alpha(theme.palette.warning.main, 0.05),
          }}
        >
          <Box sx={{ 
            width: '70px',
            height: '70px',
            borderRadius: '50%',
            backgroundColor: alpha(theme.palette.warning.main, 0.1),
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            margin: '0 auto 16px'
          }}>
            <SpeedIcon sx={{ fontSize: 32, color: theme.palette.warning.main }} />
          </Box>
          <Typography variant="h5" color="warning.main" gutterBottom>
            Cash Flow Data Required
          </Typography>
          <Typography variant="body1" color="text.secondary">
            Please upload your cash flow data on the Home page before starting the optimization process.
          </Typography>
          <Button 
            variant="outlined" 
            color="warning" 
            href="/"
            sx={{ mt: 3 }}
          >
            Go to Home Page
          </Button>
        </Paper>
      </Container>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ my: 4 }}>
      <Paper
        elevation={0}
        sx={{
          p: 4,
          mb: 4,
          borderRadius: 2,
          background: `linear-gradient(135deg, ${alpha(theme.palette.secondary.main, 0.05)} 0%, ${alpha(theme.palette.primary.main, 0.07)} 100%)`,
          border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
        }}
      >
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <TrendingUpIcon sx={{ fontSize: 28, color: theme.palette.secondary.main, mr: 1.5 }} />
            <Typography variant="h4" component="h1" fontWeight="500">
              ABS Structure Optimization
            </Typography>
          </Box>
          
          {/* "Start Over" button */}
          {(activeStep > 0 || optimizationResults) && (
            <Button 
              variant="outlined" 
              color="primary" 
              startIcon={<RestartAltIcon />}
              onClick={handleReset}
              disabled={isLoading || isOptimizing}
              sx={{ fontWeight: 500 }}
            >
              Start Over
            </Button>
          )}
        </Box>
        <Typography variant="body1" color="text.secondary">
          Optimize your asset-backed securities structure to maximize principal while maintaining buffer requirements.
          Choose an optimization method and parameters to find the optimal configuration for your tranches.
        </Typography>
      </Paper>
  
      {error && (
        <Alert 
          severity="error" 
          sx={{ 
            mb: 3, 
            borderRadius: 2,
            '& .MuiAlert-icon': {
              alignItems: 'center'
            }
          }}
        >
          {error}
        </Alert>
      )}
      
      <Box sx={{ mb: 4 }}>
        <Stepper activeStep={activeStep} alternativeLabel>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Configure Settings
            </StepLabel>
          </Step>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Run Optimization
            </StepLabel>
          </Step>
          <Step>
            <StepLabel StepIconProps={{
              sx: { '& .MuiStepIcon-text': { fontWeight: 'bold' } }
            }}>
              Review Results
            </StepLabel>
          </Step>
        </Stepper>
      </Box>
      
      {/* Progress Component - will only show when optimization is running */}
      {isOptimizing && (
        <OptimizationProgress 
          isOptimizing={isOptimizing} 
          onComplete={handleOptimizationComplete} 
        />
      )}
      
      {(activeStep === 0 || (!isOptimizing && !optimizationResults)) && (
        <Paper 
          elevation={0}
          sx={{ 
            p: 0, 
            mb: 4, 
            overflow: 'hidden',
            borderRadius: 2,
            border: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
            backgroundColor: 'background.paper'
          }}
        >
          <Box sx={{ 
            px: 3, 
            py: 2, 
            display: 'flex', 
            alignItems: 'center',
            borderBottom: `1px solid ${alpha(theme.palette.text.primary, 0.08)}`,
            backgroundColor: alpha(theme.palette.primary.main, 0.02)
          }}>
            <SettingsIcon sx={{ color: theme.palette.text.secondary, mr: 1.5 }} />
            <Typography variant="h6" fontWeight="medium">
              Optimization Settings
            </Typography>
            
            <Chip 
              label={getOptimizationMethodName(optimizationSettings.optimization_method)} 
              color="primary"
              variant="outlined"
              size="small"
              sx={{ ml: 'auto' }}
            />
          </Box>
          
          <Box sx={{ p: 3 }}>
            <OptimizationSettingsForm 
              values={optimizationSettings} 
              onChange={handleFormChange} 
            />
          </Box>
          
          <Divider />
          
          <Box sx={{ p: 3, textAlign: 'center' }}>
            <Button
              variant="contained"
              color="primary"
              size="large"
              onClick={handleOptimize}
              disabled={isLoading || isOptimizing}
              startIcon={isLoading || isOptimizing ? <CircularProgress size={20} /> : <PlayArrowIcon />}
              sx={{
                py: 1.2,
                px: 4,
                borderRadius: 2,
                fontWeight: 500
              }}
            >
              {isLoading || isOptimizing ? 'Optimizing...' : 'Run Optimization'}
            </Button>
            
            <Typography variant="body2" color="text.secondary" sx={{ mt: 2 }}>
              This process may take several minutes depending on the complexity of your data and optimization settings.
            </Typography>
          </Box>
        </Paper>
      )}
      
      {optimizationResults && !isOptimizing && (
        <OptimizationResults results={optimizationResults} />
      )}
    </Container>
  );
};

export default OptimizationPage;

======================================================================

DOSYA: src\services\apiService.js
==================================================
// frontend/src/services/apiService.js
import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000/api';

const apiClient = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 300000, // 5 dakika (300 saniye) timeout for optimization requests
});

// File upload needs different content type
const uploadFile = async (file) => {
  const formData = new FormData();
  formData.append('file', file);
  
  try {
    console.log('Uploading file:', file.name);
    const response = await axios.post(`${API_URL}/upload-excel/`, formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    });
    console.log('File upload successful');
    return response.data;
  } catch (error) {
    console.error('Error uploading file:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

const calculateResults = async (params) => {
  try {
    console.log('Calculating results with params:', params);
    const response = await apiClient.post('/calculate/', params);
    console.log('Calculation successful');
    return response.data;
  } catch (error) {
    console.error('Error calculating results:', error);
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
    }
    throw error;
  }
};

const optimizeStructure = async (params, method = 'classic') => {
  try {
    console.log(`Starting optimization with method: ${method}`);
    console.log('Optimization params:', JSON.stringify(params, null, 2));
    
    // Create a cancelable request for optimization
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();
    
    // Set up timeout to cancel if it takes too long
    const timeout = setTimeout(() => {
      source.cancel('Operation timeout: The optimization process took too long');
    }, 300000); // 5 minute timeout
    
    const response = await apiClient.post(`/optimize/${method}/`, params, {
      cancelToken: source.token
    });
    
    // Clear timeout
    clearTimeout(timeout);
    
    console.log(`${method} optimization completed successfully`);
    return response.data;
  } catch (error) {
    console.error(`Error in ${method} optimization:`, error);
    
    // Check if error was caused by cancellation
    if (axios.isCancel(error)) {
      console.log('Request canceled:', error.message);
      throw new Error('Optimization process was canceled: ' + error.message);
    }
    
    // Log detailed response info if available
    if (error.response) {
      console.error('Response status:', error.response.status);
      console.error('Response data:', error.response.data);
      
      const status = error.response.status;
      let message = 'Optimization failed';
      
      switch (status) {
        case 400:
          message = 'Invalid optimization parameters: ' + (error.response.data.detail || 'Please check your parameters');
          break;
        case 500:
          message = 'Server error during optimization. The calculation may be too complex.';
          break;
        case 504:
          message = 'Optimization timed out. Try again with simpler parameters.';
          break;
        default:
          message = `Optimization error (${status}): ` + (error.response.data.detail || error.message);
      }
      
      throw new Error(message);
    }
    
    throw error;
  }
};

// Add a progress polling function
const pollOptimizationProgress = async () => {
  try {
    const response = await apiClient.get('/optimize/progress/');
    return response.data;
  } catch (error) {
    console.error('Error polling optimization progress:', error);
    return {
      progress: 0,
      phase: 'Error',
      message: 'Failed to get progress information',
      error: true
    };
  }
};

export { uploadFile, calculateResults, optimizeStructure, pollOptimizationProgress };

======================================================================



BACKEND DOSYALARI VE Ä°Ã‡ERÄ°KLERÄ°:
==============================

DOSYA: backend\Dockerfile
==================================================
# backend/Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

======================================================================

DOSYA: backend\requirements.txt
==================================================
# backend/requirements.txt
fastapi==0.104.1
uvicorn==0.23.2
pydantic==2.4.2
pandas==2.1.1
numpy==1.26.0
python-multipart==0.0.6
openpyxl==3.1.2
python-dateutil==2.8.2
scikit-optimize==0.9.0

======================================================================

DOSYA: backend\app\main.py
==================================================
import time
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from app.routers import calculation, optimization
import uvicorn

app = FastAPI(
    title="ABS Analysis Tool",
    description="Cash flow analysis for securitization",
    version="1.0.0"
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify the actual frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add GZip compression for faster responses
app.add_middleware(GZipMiddleware, minimum_size=1000)

# Add custom middleware for timeout and performance tracking
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response

# Include routers
app.include_router(calculation.router, prefix="/api", tags=["Calculation"])
app.include_router(optimization.router, prefix="/api", tags=["Optimization"])

@app.get("/")
async def root():
    return {"message": "ABS Analysis Tool API is running"}

# Configure server settings if run directly
if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        timeout_keep_alive=600,  # 10 dakika keep-alive timeout
        workers=1,  # Optimization iÅŸlemi iÃ§in tek bir iÅŸÃ§i daha iyi olabilir
    )

======================================================================

DOSYA: backend\app\__init__.py
==================================================


======================================================================

DOSYA: backend\app\models\input_models.py
==================================================
from pydantic import BaseModel, Field
from typing import List, Optional
from datetime import date

class GeneralSettings(BaseModel):
    start_date: date
    operational_expenses: float
    min_buffer: float

class TrancheA(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float
    nominal: float

class TrancheB(BaseModel):
    maturity_days: int
    base_rate: float
    spread: float
    reinvest_rate: float

class NPVSettings(BaseModel):
    method: str  # "weighted_avg_rate" or "custom_rate"
    custom_rate: Optional[float] = None

class OptimizationSettings(BaseModel):
    optimization_method: str = Field(default="classic")
    selected_strategies: List[str] = Field(default=["equal", "increasing", "decreasing", "middle_weighted"])
    a_tranches_range: List[int] = Field(default=[2, 6])
    maturity_range: List[int] = Field(default=[32, 365])
    maturity_step: int = Field(default=10)
    min_class_b_percent: float = Field(default=10.0)
    target_class_b_coupon_rate: float = Field(default=30.0)
    additional_days_for_class_b: int = Field(default=10)
    
    # Evolutionary algorithm parameters
    population_size: Optional[int] = Field(default=50)
    num_generations: Optional[int] = Field(default=40)

class CalculationRequest(BaseModel):
    general_settings: GeneralSettings
    tranches_a: List[TrancheA]
    tranche_b: TrancheB
    npv_settings: NPVSettings

======================================================================

DOSYA: backend\app\models\output_models.py
==================================================
# backend/app/models/output_models.py
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

class CashFlowSummary(BaseModel):
    total_records: int
    total_principal: float
    total_interest: float
    total_cash_flow: float
    date_range: List[str]
    
class CalculationResult(BaseModel):
    class_a_total: float
    class_b_total: float
    class_a_principal: float
    class_b_principal: float
    class_a_interest: float
    class_b_coupon: float
    min_buffer_actual: float
    total_principal_paid: float
    total_loan_principal: float
    financing_cost: float
    tranche_results: List[Dict[str, Any]]
    interest_rate_conversions: List[Dict[str, Any]]
    
class OptimizationResult(BaseModel):
    best_strategy: str
    class_a_maturities: List[int]
    class_a_nominals: List[float]
    class_a_rates: List[float]
    class_a_reinvest: List[float]
    class_b_maturity: int
    class_b_rate: float
    class_b_reinvest: float
    class_b_nominal: float
    class_b_coupon_rate: float
    min_buffer_actual: float
    last_cash_flow_day: int
    additional_days: int
    results_by_strategy: Dict[str, Dict[str, Any]]

======================================================================

DOSYA: backend\app\routers\calculation.py
==================================================
# backend/app/routers/calculation.py
from fastapi import APIRouter, UploadFile, File, HTTPException
from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult, CashFlowSummary
from app.services.calculation_service import perform_calculation, load_excel_data
import pandas as pd
from typing import Dict, Any
import io

router = APIRouter()

# Global variable to store the dataframe after upload
# In a production app, you would use a database or Redis cache instead
df_store = {"df": None}

@router.post("/upload-excel/", response_model=CashFlowSummary)
async def upload_excel(file: UploadFile = File(...)):
    try:
        contents = await file.read()
        df = load_excel_data(contents)
        
        # Store the dataframe in memory for later use
        df_store["df"] = df
        
        # Return summary data
        return CashFlowSummary(
            total_records=len(df),
            total_principal=float(df['principal_amount'].sum()),
            total_interest=float(df['interest_amount'].sum()),
            total_cash_flow=float(df['cash_flow'].sum()),
            date_range=[df['installment_date'].min().strftime('%d/%m/%Y'), 
                      df['installment_date'].max().strftime('%d/%m/%Y')]
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Could not process file: {str(e)}")

@router.post("/calculate/", response_model=CalculationResult)
async def calculate(request: CalculationRequest):
    try:
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Perform the calculation
        result = perform_calculation(df, request)
        return result
    except Exception as e:
        raise HTTPException(status_code=400, detail=f"Calculation error: {str(e)}")

======================================================================

DOSYA: backend\app\routers\optimization.py
==================================================
import time
import traceback
import logging
import asyncio
from fastapi.responses import JSONResponse
from fastapi import APIRouter, HTTPException, Path
from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult

# Import the optimization_progress object and all optimization functions
from app.services.optimization_service import (
    optimization_progress,  # Import the progress tracker
    perform_optimization, 
    perform_genetic_optimization
)
from app.routers.calculation import df_store  # Import the shared dataframe store

# Configure logger
logger = logging.getLogger(__name__)

router = APIRouter()

@router.post("/optimize/classic/", response_model=OptimizationResult)
async def optimize_classic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        # Get the stored dataframe
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting classic optimization with parameters: {optimization_settings}")
        
        # Perform the optimization with classic method in a separate thread
        # to not block the event loop and allow progress updates
        def run_optimization():
            return perform_optimization(df, general_settings, optimization_settings)
        
        # Run the CPU-bound optimization task in a thread pool
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, run_optimization)
        
        # Log success
        logger.info("Classic optimization completed successfully")
        
        # Ensure progress is set to 100% when complete
        optimization_progress.update(
            step=100,
            phase="Complete",
            message="Optimization completed successfully"
        )
        
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Classic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Update progress tracker in case of error (don't reset)
        optimization_progress.update(
            phase="Error",
            message=f"Classic optimization error: {str(e)}",
            step=100
        )
        
        raise HTTPException(status_code=500, detail=f"Classic optimization error: {str(e)}")

@router.post("/optimize/genetic/", response_model=OptimizationResult)
async def optimize_genetic(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    try:
        # Reset progress tracker
        optimization_progress.reset()
        
        df = df_store.get("df")
        if df is None:
            raise HTTPException(status_code=400, detail="No data found. Please upload Excel file first.")
        
        # Log the request
        logger.info(f"Starting genetic optimization with parameters: {optimization_settings}")
        
        # Perform the optimization in a separate thread
        def run_optimization():
            return perform_genetic_optimization(df, general_settings, optimization_settings)
        
        # Run the CPU-bound optimization task in a thread pool
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(None, run_optimization)
        
        # Log success
        logger.info("Genetic optimization completed successfully")
        
        # Ensure progress is set to 100% when complete
        optimization_progress.update(
            step=100,
            phase="Complete",
            message="Optimization completed successfully"
        )
        
        return result
    except Exception as e:
        # Log the error
        logger.error(f"Genetic optimization error: {str(e)}")
        logger.error(traceback.format_exc())
        
        # Update progress tracker in case of error (don't reset)
        optimization_progress.update(
            phase="Error",
            message=f"Genetic optimization error: {str(e)}",
            step=100
        )
        
        raise HTTPException(status_code=500, detail=f"Genetic optimization error: {str(e)}")

# Backward compatibility main endpoint - updated to only support classic and genetic
@router.post("/optimize/", response_model=OptimizationResult)
async def optimize(
    optimization_settings: OptimizationSettings,
    general_settings: GeneralSettings
):
    method = getattr(optimization_settings, "optimization_method", "classic")
    logger.info(f"Optimizing with method: {method}")
    
    # Reset progress before starting
    optimization_progress.reset()
    
    # Add timeout handling
    try:
        # SÄ±nÄ±rlÄ± kombinasyon sayÄ±sÄ± ve iterasyon
        if hasattr(optimization_settings, "maturity_range") and len(optimization_settings.maturity_range) == 2:
            # Ä°ÅŸlem sÃ¼resini azaltmak iÃ§in parametreleri sÄ±nÄ±rla
            range_diff = optimization_settings.maturity_range[1] - optimization_settings.maturity_range[0]
            if range_diff > 200 and optimization_settings.maturity_step < 15:
                logger.warning(f"Large maturity range ({range_diff}) with small step ({optimization_settings.maturity_step}). Adjusting step.")
                optimization_settings.maturity_step = max(15, optimization_settings.maturity_step)
        
        if method == "classic":
            return await optimize_classic(optimization_settings, general_settings)
        elif method == "genetic":
            return await optimize_genetic(optimization_settings, general_settings)
        else:
            # Default to classic method for any unsupported types
            logger.warning(f"Unknown optimization method: {method}, defaulting to classic")
            optimization_settings.optimization_method = "classic"
            return await optimize_classic(optimization_settings, general_settings)
    except Exception as e:
        # GÃ¼ncelleme yapmak iÃ§in hata durumunda progress'i gÃ¼ncelle
        optimization_progress.update(
            phase="Error", 
            message=f"Optimization error: {str(e)}",
            step=100
        )
        
        logger.error(f"Error in main optimize endpoint: {str(e)}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Optimization error: {str(e)}")

@router.get("/optimize/progress/")
async def get_optimization_progress():
    """Get the current status of the optimization process"""
    # Ä°lerleme sÄ±fÄ±rlanmÄ±ÅŸ olabileceÄŸinden force_update
    progress_data = optimization_progress.get_info()
    logger.debug(f"Progress data: {progress_data}")  # Debugging iÃ§in loglama ekleyin
    return progress_data

======================================================================

DOSYA: backend\app\services\calculation_service.py
==================================================
# backend/app/services/calculation_service.py
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from app.models.input_models import CalculationRequest
from app.models.output_models import CalculationResult
from app.utils.finance_utils import (
    simple_to_compound_annual, 
    simple_to_maturity_compound, 
    overnight_to_annual_compound,
    get_next_business_day,
    calculate_reinvestment_date
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)
from typing import Dict, List, Any, Tuple
import io

def load_excel_data(contents: bytes) -> pd.DataFrame:
    """Load and preprocess Excel data"""
    try:
        df = pd.read_excel(io.BytesIO(contents))
        df.rename(columns={'Copyinstallment_date': 'installment_date'}, inplace=True, errors='ignore')
        df['installment_date'] = pd.to_datetime(df['installment_date'], dayfirst=True, errors='coerce')
        
        if 'principal_amount' not in df.columns or 'interest_amount' not in df.columns:
            raise ValueError("The Excel file does not contain 'principal_amount' or 'interest_amount' columns.")
        
        df['cash_flow'] = df['principal_amount'] + df['interest_amount']
        # Save original cash flows
        df['original_cash_flow'] = df['cash_flow'].copy()
        
        return df
    except Exception as e:
        raise ValueError(f"Error processing Excel file: {str(e)}")

def perform_calculation(df: pd.DataFrame, request: CalculationRequest) -> CalculationResult:
    """Perform ABS calculation based on provided parameters"""
    # Extract request parameters
    start_date = pd.Timestamp(request.general_settings.start_date)
    ops_expenses = request.general_settings.operational_expenses
    min_buffer = request.general_settings.min_buffer
    
    # Apply operational expenses
    df_calc = df.copy()
    df_calc['cash_flow'] = df_calc['original_cash_flow'].copy()
    target_date = pd.Timestamp('2025-02-16')
    target_rows = df_calc[df_calc['installment_date'].dt.date == target_date.date()]
    
    if not target_rows.empty:
        t_idx = target_rows.index[0]
        orig_cf = df_calc.at[t_idx, 'cash_flow']
        new_cf = max(0, orig_cf - ops_expenses)
        df_calc.at[t_idx, 'cash_flow'] = new_cf
    
    # Extract tranche parameters
    a_maturity_days = [t.maturity_days for t in request.tranches_a]
    a_base_rates = [t.base_rate for t in request.tranches_a]
    a_spreads = [t.spread for t in request.tranches_a]
    a_reinvest_rates = [t.reinvest_rate for t in request.tranches_a]
    a_nominal_amounts = [t.nominal for t in request.tranches_a]
    
    b_maturity_days = [request.tranche_b.maturity_days]
    b_base_rates = [request.tranche_b.base_rate]
    b_spreads = [request.tranche_b.spread]
    b_reinvest_rates = [request.tranche_b.reinvest_rate]
    
    # Calculate B nominal amount
    total_a_nominal = sum(a_nominal_amounts)
    percent_b = 10.17811704
    b_nominal_amount = (total_a_nominal * percent_b) / (100 - percent_b)
    b_nominal_amount = round(b_nominal_amount / 1000) * 1000
    b_nominal = [b_nominal_amount]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = a_base_rates + b_base_rates
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = a_reinvest_rates + b_reinvest_rates
    all_nominal = a_nominal_amounts + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    # Distribute cash flows into tranches
    tranch_cash_flows = assign_cash_flows_to_tranches(
        df_calc, start_date, all_maturity_dates, all_reinvest_rates
    )
    
    # Calculate results for each tranche
    results = []
    buffer = 0.0
    interest_rate_conversions = []
    
    for i in range(len(all_maturity_days)):
        is_class_a = (i < len(a_maturity_days))
        
        # Set tranche name
        if is_class_a:
            t_name = f"Class A{i+1}"
        else:
            t_name = f"Class B{i - len(a_maturity_days) + 1}"
        
        # Calculate cash flow totals
        c_flow, r_return, total_principal, total_interest = calculate_totals(
            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
        )
        
        # Buffer reinvestment calculation
        if i > 0 and buffer > 0:
            dd = all_maturity_days[i] - all_maturity_days[i-1]
            if dd > 0:
                factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                buffer_reinv = buffer * factor
            else:
                buffer_reinv = 0
        else:
            buffer_reinv = 0
        
        # Total available funds
        total_available = c_flow + r_return + buffer + buffer_reinv
        
        # Interest rate calculations
        base_rate_val = all_base_rates[i]
        spread_bps = all_spreads[i]
        total_rate = base_rate_val + (spread_bps/100.0)
        
        if is_class_a:
            # Class A payment logic
            nominal_pmt = all_nominal[i]
            
            discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
            principal = nominal_pmt * discount_factor
            interest = nominal_pmt - principal
            coupon_payment = 0
            coupon_rate = 0.0
            
            total_payment = nominal_pmt
        else:
            # Class B payment logic
            nominal_pmt = all_nominal[i]
            principal = nominal_pmt
            coupon_payment = max(0, total_available - principal)
            interest = 0
            coupon_rate = (coupon_payment / principal * 100) if principal > 0 else 0.0
            discount_factor = 1.0
            
            total_payment = principal + coupon_payment
        
        # Calculate buffer
        new_buffer = max(0, total_available - total_payment)
        buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt != 0 else 0
        
        # Calculate effective interest rates
        if is_class_a:
            final_simple = total_rate
            total_interest_rate_percent = total_rate
            effective_coupon_rate = 0.0
        else:
            final_simple = coupon_rate
            total_interest_rate_percent = 0.0
            effective_coupon_rate = (coupon_payment / principal) * (365 / all_maturity_days[i]) * 100 if principal > 0 and all_maturity_days[i] > 0 else 0.0
        
        # Interest rate conversions
        if is_class_a:
            comp_period = simple_to_maturity_compound(final_simple, all_maturity_days[i])
            simple_annual_display = final_simple
            compound_period_display = comp_period
        else:
            # For Class B, use dash ("-") for these values
            simple_annual_display = "-"
            compound_period_display = "-"
        
        reinvest_on_comp = overnight_to_annual_compound(all_reinvest_rates[i])
        
        interest_rate_conversions.append({
            "Tranche": t_name,
            "Maturity Days": all_maturity_days[i],
            "Simple Annual Interest (%)": simple_annual_display,
            "Compound Interest for Period (%)": compound_period_display,
            "Reinvest Simple Annual (%)": all_reinvest_rates[i],
            "Reinvest O/N Compound (%)": reinvest_on_comp,
            "Coupon Rate (%)": coupon_rate if not is_class_a else 0.0,
            "Effective Coupon Rate (%)": effective_coupon_rate if not is_class_a else 0.0
        })
        
        # Add to results
        results.append({
            "Tranche": t_name,
            "Start Date": start_date.strftime("%d/%m/%Y"),
            "Maturity Days": all_maturity_days[i],
            "Maturity Date": all_maturity_dates[i].strftime("%d/%m/%Y"),
            "Base Rate (%)": base_rate_val,
            "Spread (bps)": spread_bps,
            "Total Interest Rate (%)": total_interest_rate_percent,
            "Coupon Rate (%)": coupon_rate,
            "Effective Coupon (%)": effective_coupon_rate,
            "Original Nominal": all_nominal[i],
            "Adjusted Nominal": nominal_pmt,
            "Buffer In": buffer,
            "Cash Flow Total": c_flow,
            "Reinvestment Return": r_return,
            "Buffer Reinvestment": buffer_reinv,
            "Total Available": total_available,
            "Principal": principal,
            "Interest": interest,
            "Coupon Payment": coupon_payment,
            "Nominal Payment": nominal_pmt,
            "Total Payment": total_payment,
            "Buffer Out": new_buffer,
            "Buffer Cash Flow Ratio (%)": buffer_cf_ratio,
            "Discount Factor": discount_factor,
            "Is Class A": is_class_a
        })
        
        # Update buffer for next tranche
        buffer = new_buffer
    
    # Filter for Class A and Class B
    class_a_results = [r for r in results if r.get("Is Class A")]
    class_b_results = [r for r in results if not r.get("Is Class A")]
    
    # Calculate totals
    class_a_total = sum(r["Total Payment"] for r in class_a_results)
    class_b_total = sum(r["Total Payment"] for r in class_b_results)
    class_a_principal = sum(r["Principal"] for r in class_a_results)
    class_b_principal = sum(r["Principal"] for r in class_b_results)
    class_a_interest = sum(r["Interest"] for r in class_a_results)
    class_b_coupon = sum(r["Coupon Payment"] for r in class_b_results)
    min_buffer_actual = min(r["Buffer Cash Flow Ratio (%)"] for r in class_a_results) if class_a_results else 0.0
    
    # Calculate total principal paid and loan principal for financing cost
    total_principal_paid = class_a_principal + class_b_principal
    total_loan_principal = df_calc['principal_amount'].sum()
    financing_cost = total_principal_paid - total_loan_principal
    
    # Create and return the calculation result
    return CalculationResult(
        class_a_total=class_a_total,
        class_b_total=class_b_total,
        class_a_principal=class_a_principal,
        class_b_principal=class_b_principal,
        class_a_interest=class_a_interest,
        class_b_coupon=class_b_coupon,
        min_buffer_actual=min_buffer_actual,
        total_principal_paid=total_principal_paid,
        total_loan_principal=total_loan_principal,
        financing_cost=financing_cost,
        tranche_results=results,
        interest_rate_conversions=interest_rate_conversions
    )

======================================================================

DOSYA: backend\app\services\optimization_service.py
==================================================
"""
Optimization service for ABS structure analysis.
This module implements multiple optimization strategies to find optimal ABS configurations.
"""
import time
import pandas as pd
import numpy as np
import itertools
from datetime import datetime, timedelta
import random
import traceback
import logging
from typing import Dict, List, Any, Tuple, Optional

from app.models.input_models import OptimizationSettings, GeneralSettings
from app.models.output_models import OptimizationResult
from app.utils.finance_utils import (
    simple_to_compound_annual,
    get_nearest_maturity,
    get_last_cash_flow_day
)
from app.utils.cash_flow_utils import (
    assign_cash_flows_to_tranches,
    calculate_totals
)

# Configure logger
logger = logging.getLogger(__name__)

class OptimizationProgress:
    """Class to track and report optimization progress"""
    def __init__(self):
        self.reset()
        
    def reset(self):
        """Reset all progress tracking variables"""
        self.current_step = 0
        self.total_steps = 100
        self.current_phase = "Initializing"
        self.status_message = "Starting optimization..."
        self.progress = 0
        self.last_update_time = time.time()
        self.start_time = time.time()
        logger.info("Progress tracker reset")
        
    def update(self, step=None, total=None, phase=None, message=None):
        """Update progress information"""
        current_time = time.time()
        
        # Update more frequently
        force_update = (current_time - self.last_update_time) > 0.2
        
        if step is not None:
            self.current_step = step
        if total is not None:
            self.total_steps = total
        if phase is not None:
            self.current_phase = phase
        if message is not None:
            self.status_message = message
            
        # Calculate percentage
        if self.total_steps > 0:
            new_progress = min(99, int((self.current_step / self.total_steps) * 100))
            if self.current_phase == "Complete" or self.current_phase == "Error":
                new_progress = 100  # Set to 100% when complete or error
            
            progress_changed = new_progress != self.progress
            self.progress = new_progress
        
        # Log progress updates
        if phase is not None or message is not None or progress_changed or force_update:
            elapsed = current_time - self.start_time
            logger.info(f"Progress: {self.progress}% - {self.current_phase} - {self.status_message} (elapsed: {elapsed:.1f}s)")
            self.last_update_time = current_time
        
    def get_info(self):
        """Get current progress information with additional data"""
        current_time = time.time()
        elapsed = current_time - self.start_time
        
        return {
            "progress": self.progress,
            "phase": self.current_phase,
            "message": self.status_message,
            "step": self.current_step,
            "total_steps": self.total_steps,
            "timestamp": current_time,
            "elapsed_seconds": elapsed,
            "start_time": self.start_time
        }

# Create the global optimization_progress instance
optimization_progress = OptimizationProgress()

def adjust_class_a_nominals_for_target_coupon(
    a_nominals: List[float], 
    class_b_nominal: float, 
    target_coupon_rate: float, 
    class_b_maturity: int,
    a_maturity_days: List[int], 
    a_base_rates: List[float], 
    a_reinvest_rates: List[float], 
    b_base_rate: float, 
    b_reinvest_rate: float,
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame, 
    min_buffer: float,
    max_allowed_diff: float = 1.0
) -> Tuple[List[float], bool]:
    """
    Iteratively adjust Class A nominal amounts to achieve a target coupon rate for Class B
    using an adaptive binary search approach.
    
    Args:
        a_nominals: List of Class A nominal amounts
        class_b_nominal: Class B nominal amount
        target_coupon_rate: Target coupon rate for Class B
        class_b_maturity: Maturity days for Class B
        a_maturity_days: List of maturity days for Class A tranches
        a_base_rates: List of base rates for Class A tranches
        a_reinvest_rates: List of reinvestment rates for Class A tranches
        b_base_rate: Base rate for Class B
        b_reinvest_rate: Reinvestment rate for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        min_buffer: Minimum buffer requirement
        max_allowed_diff: Maximum allowed difference between actual and target coupon rate
        
    Returns:
        Tuple of (adjusted_nominals, success_flag)
    """
    # Initial parameters
    original_a_total = sum(a_nominals)
    original_proportions = [n / original_a_total for n in a_nominals]
    max_iterations = 50
    
    # Adjustment limits 
    min_adjustment = 0.001  # Allow down to 0.1% of original
    max_adjustment = 3.0    # Allow up to 300% of original
    
    logger.info(f"Starting adjustment with target coupon rate: {target_coupon_rate:.2f}%")
    logger.info(f"Original Class A total: {original_a_total:,.2f}, Class B nominal: {class_b_nominal:,.2f}")
    
    # First, evaluate the original nominals to get a baseline
    try:
        baseline_coupon_rate, baseline_min_buffer = evaluate_coupon_rate(
            a_nominals, class_b_nominal, class_b_maturity, 
            a_maturity_days, a_base_rates, a_reinvest_rates, 
            b_base_rate, b_reinvest_rate, start_date, df_temp
        )
        
        logger.info(f"Baseline - Coupon rate: {baseline_coupon_rate:.2f}%, Buffer: {baseline_min_buffer:.2f}%")
    except Exception as e:
        logger.error(f"Error evaluating baseline: {str(e)}")
        return a_nominals, False
    
    # Determine initial direction and starting adjustment
    if baseline_coupon_rate < target_coupon_rate:
        # If baseline coupon is too low, we need to increase Class A nominals
        logger.info("Baseline coupon is lower than target - will increase Class A nominals")
        adjustment_direction = 1  # Increase
        current_adjustment = 1.2  # Start with 20% increase
    else:
        # If baseline coupon is too high, we need to decrease Class A nominals
        logger.info("Baseline coupon is higher than target - will decrease Class A nominals")
        adjustment_direction = -1  # Decrease
        
        # Set a very aggressive initial adjustment based on how far we are
        coupon_ratio = baseline_coupon_rate / target_coupon_rate
        if coupon_ratio > 10:
            # If coupon is more than 10x target, use extreme adjustment
            current_adjustment = 0.01  # 1% of original size
        elif coupon_ratio > 5:
            # If coupon is more than 5x target, use very aggressive adjustment
            current_adjustment = 0.05  # 5% of original size
        elif coupon_ratio > 2:
            # If coupon is more than 2x target, use aggressive adjustment
            current_adjustment = 0.1   # 10% of original size
        else:
            # For closer ratios, use moderate adjustment
            current_adjustment = 0.5   # 50% of original size
    
    best_diff = float('inf')
    best_nominals = a_nominals.copy()
    success = False
    
    # Adaptive binary search with safeguards
    for iteration in range(max_iterations):
        # Apply current adjustment factor to all Class A nominals
        current_nominals = [original_proportions[i] * original_a_total * current_adjustment 
                           for i in range(len(a_nominals))]
        
        # Round to nearest 1000 and ensure no zeros
        current_nominals = [max(1000, round(n / 1000) * 1000) for n in current_nominals]
        
        try:
            # Evaluate with current adjustment
            coupon_rate, min_buffer_actual = evaluate_coupon_rate(
                current_nominals, class_b_nominal, class_b_maturity, 
                a_maturity_days, a_base_rates, a_reinvest_rates,
                b_base_rate, b_reinvest_rate, start_date, df_temp
            )
            
            # Calculate difference from target
            rate_diff = abs(coupon_rate - target_coupon_rate)
            
            logger.info(f"Iteration {iteration+1}, adjustment: {current_adjustment:.4f}, "
                  f"coupon: {coupon_rate:.2f}%, target: {target_coupon_rate:.2f}%, "
                  f"diff: {rate_diff:.2f}%, min buffer: {min_buffer_actual:.2f}%")
            
            # Check if this result is better and meets buffer requirement
            if min_buffer_actual >= min_buffer and rate_diff < best_diff:
                best_diff = rate_diff
                best_nominals = current_nominals.copy()
                
                # If we're close to target, consider it a success
                if rate_diff <= max_allowed_diff:
                    success = True
                    logger.info(f"Found acceptable solution - coupon rate: {coupon_rate:.2f}%, "
                          f"diff: {rate_diff:.2f}%, min buffer: {min_buffer_actual:.2f}%")
                    
                    # If very close to target, we can exit early
                    if rate_diff < 0.2:
                        break
            
            # Adaptive adjustment based on current results
            if coupon_rate < target_coupon_rate:
                if adjustment_direction == 1:
                    # We're going in the right direction (increasing), make smaller adjustments
                    current_adjustment *= 1.1  # Increase by 10%
                else:
                    # We went too far, reverse direction and use smaller step
                    adjustment_direction = 1
                    current_adjustment = 1.0 + (1.0 - current_adjustment) * 0.5
            else:  # coupon_rate > target_coupon_rate
                if adjustment_direction == -1:
                    # We're going in the right direction (decreasing), make smaller adjustments
                    if (coupon_rate / target_coupon_rate) > 2:
                        # Still far from target, be more aggressive
                        current_adjustment *= 0.7  # Reduce by 30%
                    else:
                        # Getting closer, be more careful
                        current_adjustment *= 0.9  # Reduce by 10%
                else:
                    # We went too far, reverse direction and use smaller step
                    adjustment_direction = -1
                    current_adjustment = 1.0 - (current_adjustment - 1.0) * 0.5
            
            # Ensure adjustment is within bounds
            current_adjustment = max(min_adjustment, min(max_adjustment, current_adjustment))
            
            # Check if we're making too small changes and break if needed
            if abs(current_adjustment - 1.0) < 0.0001 and iteration > 10:
                logger.info("Adjustment factor converged, stopping iterations")
                break
                
        except Exception as e:
            logger.error(f"Error during adjustment iteration {iteration}: {str(e)}")
            # Continue to next iteration instead of terminating
            continue
    
    # If we didn't find a solution within max_allowed_diff but have a best solution, log it
    if not success and best_diff < float('inf'):
        logger.info(f"Best solution found: coupon rate diff: {best_diff:.2f}%")
    elif not success:
        logger.info(f"Failed to find valid solution. Try adjusting min buffer requirement or target coupon rate.")
    
    return best_nominals, success

def evaluate_coupon_rate(
    a_nominals: List[float], 
    class_b_nominal: float, 
    class_b_maturity: int, 
    a_maturity_days: List[int], 
    a_base_rates: List[float], 
    a_reinvest_rates: List[float],
    b_base_rate: float, 
    b_reinvest_rate: float, 
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame
) -> Tuple[float, float]:
    """
    Helper function to evaluate a specific nominal adjustment
    Returns tuple of (coupon_rate, min_buffer)
    
    Args:
        a_nominals: List of Class A nominal amounts
        class_b_nominal: Class B nominal amount
        class_b_maturity: Maturity days for Class B
        a_maturity_days: List of maturity days for Class A tranches
        a_base_rates: List of base rates for Class A tranches
        a_reinvest_rates: List of reinvestment rates for Class A tranches
        b_base_rate: Base rate for Class B
        b_reinvest_rate: Reinvestment rate for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        
    Returns:
        Tuple of (coupon_rate, min_buffer)
    """
    # Set up parameters for calculation
    a_spreads = [0.0] * len(a_maturity_days)
    b_maturity_days = [class_b_maturity]
    b_nominal = [class_b_nominal]
    b_spreads = [0.0]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = a_base_rates + [b_base_rate]
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = a_reinvest_rates + [b_reinvest_rate]
    all_nominal = a_nominals + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    # Distribute cash flows to tranches
    tranch_cash_flows = assign_cash_flows_to_tranches(
        df_temp, start_date, all_maturity_dates, all_reinvest_rates
    )
    
    # Calculate results for each tranche
    results = []
    buffer = 0.0
    
    for i in range(len(all_maturity_days)):
        is_class_a = (i < len(a_maturity_days))
        
        # Calculate cash flow totals
        c_flow, r_return, total_principal, total_interest = calculate_totals(
            tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
        )
        
        # Buffer reinvestment calculation
        if i > 0 and buffer > 0:
            dd = all_maturity_days[i] - all_maturity_days[i-1]
            if dd > 0:
                factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                buffer_reinv = buffer * factor
            else:
                buffer_reinv = 0
        else:
            buffer_reinv = 0
        
        # Total available funds
        total_available = c_flow + r_return + buffer + buffer_reinv
        
        # Interest rate calculations
        base_rate_val = all_base_rates[i]
        spread_bps = all_spreads[i]
        total_rate = base_rate_val + (spread_bps/100.0)
        
        if is_class_a:
            # Class A payment logic
            nominal_pmt = all_nominal[i]
            discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
            principal = nominal_pmt * discount_factor
            interest = nominal_pmt - principal
            coupon_payment = 0
            total_payment = nominal_pmt
        else:
            # Class B payment logic
            nominal_pmt = all_nominal[i]
            principal = nominal_pmt
            coupon_payment = max(0, total_available - principal)
            interest = 0
            total_payment = principal + coupon_payment
        
        # Calculate buffer - avoid division by zero
        new_buffer = max(0, total_available - total_payment)
        buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt > 0 else 0
        
        # Add to results
        results.append({
            "is_class_a": is_class_a,
            "principal": principal,
            "interest": interest,
            "coupon_payment": coupon_payment,
            "total_payment": total_payment,
            "buffer_cf_ratio": buffer_cf_ratio,
            "maturity_days": all_maturity_days[i],
            "base_rate": base_rate_val,
            "nominal": all_nominal[i]
        })
        
        # Update buffer for next tranche
        buffer = new_buffer
    
    # Split results by class
    class_a_results = [r for r in results if r['is_class_a']]
    class_b_results = [r for r in results if not r['is_class_a']]
    
    # Calculate Class B coupon rate
    class_b_principal = sum(r['principal'] for r in class_b_results)
    class_b_coupon = sum(r['coupon_payment'] for r in class_b_results)
    
    # Calculate Class B effective coupon rate (annualized)
    if class_b_results and class_b_principal > 0 and class_b_maturity > 0:
        class_b_maturity_days = class_b_results[0]['maturity_days']
        class_b_coupon_rate = (class_b_coupon / class_b_principal) * (365 / class_b_maturity_days) * 100
    else:
        class_b_coupon_rate = 0.0
    
    # Calculate minimum buffer
    min_buffer_actual = min(r['buffer_cf_ratio'] for r in class_a_results) if class_a_results else 0.0
    
    return class_b_coupon_rate, min_buffer_actual

def evaluate_params(
    maturities: List[int], 
    nominals: List[float], 
    class_b_maturity: int, 
    start_date: pd.Timestamp, 
    df_temp: pd.DataFrame,
    maturity_to_base_rate_A: Dict[int, float], 
    maturity_to_reinvest_rate_A: Dict[int, float],
    class_b_base_rate: float, 
    class_b_reinvest_rate: float,
    min_class_b_percent: float, 
    target_class_b_coupon_rate: float, 
    min_buffer: float
) -> Dict[str, Any]:
    """Helper function to evaluate a set of parameters
    
    Args:
        maturities: List of maturity days for Class A tranches
        nominals: List of nominal amounts for Class A tranches
        class_b_maturity: Maturity days for Class B
        start_date: Start date for calculations
        df_temp: DataFrame containing cash flow data
        maturity_to_base_rate_A: Dictionary mapping maturity days to base rates
        maturity_to_reinvest_rate_A: Dictionary mapping maturity days to reinvestment rates
        class_b_base_rate: Base rate for Class B
        class_b_reinvest_rate: Reinvestment rate for Class B
        min_class_b_percent: Minimum percentage of Class B tranche
        target_class_b_coupon_rate: Target coupon rate for Class B
        min_buffer: Minimum buffer requirement
        
    Returns:
        Dictionary containing evaluation results
    """
    # Convert to lists for key operations and ensure types are correct
    maturities = [int(m) for m in maturities]  # Ensure integers
    nominals = list(nominals)
    
    # Round nominals to nearest 1000 and ensure no zeros
    nominals = [max(1000, round(n / 1000) * 1000) for n in nominals]
    
    # Get rates from lookup tables with fallback values
    available_lookup_keys = list(maturity_to_base_rate_A.keys())
    base_rates = [maturity_to_base_rate_A.get(
        get_nearest_maturity(m, available_lookup_keys), 42.0) for m in maturities]
    
    reinvest_rates = [maturity_to_reinvest_rate_A.get(
        get_nearest_maturity(m, list(maturity_to_reinvest_rate_A.keys())), 30.0) for m in maturities]
    
    # Calculate Class B nominal based on minimum percentage
    total_a_nominal = sum(nominals)
    if total_a_nominal <= 0:
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': "Total Class A nominal must be positive",
            'b_nominal': 0
        }
        
    class_b_nominal = (total_a_nominal * min_class_b_percent) / (100 - min_class_b_percent)
    
    # Set up parameters for calculation
    a_maturity_days = maturities
    a_spreads = [0.0] * len(a_maturity_days)
    b_maturity_days = [int(class_b_maturity)]  # Ensure integer
    b_nominal = [class_b_nominal]
    b_spreads = [0.0]
    
    # Combine all parameters
    all_maturity_days = a_maturity_days + b_maturity_days
    all_base_rates = base_rates + [class_b_base_rate]
    all_spreads = a_spreads + b_spreads
    all_reinvest_rates = reinvest_rates + [class_b_reinvest_rate]
    all_nominal = nominals + b_nominal
    
    # Calculate maturity dates
    all_maturity_dates = [start_date + pd.Timedelta(days=days) for days in all_maturity_days]
    
    try:
        # Distribute cash flows to tranches
        tranch_cash_flows = assign_cash_flows_to_tranches(
            df_temp, start_date, all_maturity_dates, all_reinvest_rates
        )
        
        # Calculate results for each tranche
        results = []
        buffer = 0.0
        
        for i in range(len(all_maturity_days)):
            is_class_a = (i < len(a_maturity_days))
            
            # Calculate cash flow totals
            c_flow, r_return, total_principal, total_interest = calculate_totals(
                tranch_cash_flows[i], all_maturity_dates[i], all_reinvest_rates[i]
            )
            
            # Buffer reinvestment calculation
            if i > 0 and buffer > 0:
                dd = all_maturity_days[i] - all_maturity_days[i-1]
                if dd > 0:
                    factor = (1 + simple_to_compound_annual(all_reinvest_rates[i])/100)**(dd/365) - 1
                    buffer_reinv = buffer * factor
                else:
                    buffer_reinv = 0
            else:
                buffer_reinv = 0
            
            # Total available funds
            total_available = c_flow + r_return + buffer + buffer_reinv
            
            # Interest rate calculations
            base_rate_val = all_base_rates[i]
            spread_bps = all_spreads[i]
            total_rate = base_rate_val + (spread_bps/100.0)
            
            if is_class_a:
                # Class A payment logic
                nominal_pmt = all_nominal[i]
                discount_factor = 1 / (1 + (total_rate/100 * all_maturity_days[i]/365)) if all_maturity_days[i] > 0 else 1
                principal = nominal_pmt * discount_factor
                interest = nominal_pmt - principal
                coupon_payment = 0
                total_payment = nominal_pmt
            else:
                # Class B payment logic
                nominal_pmt = all_nominal[i]
                principal = nominal_pmt
                coupon_payment = max(0, total_available - principal)
                interest = 0
                total_payment = principal + coupon_payment
            
            # Calculate buffer - avoid division by zero
            new_buffer = max(0, total_available - total_payment)
            buffer_cf_ratio = (new_buffer / nominal_pmt * 100) if nominal_pmt > 0 else 0
            
            # Add to results
            results.append({
                "is_class_a": is_class_a,
                "principal": principal,
                "interest": interest,
                "coupon_payment": coupon_payment,
                "total_payment": total_payment,
                "buffer_cf_ratio": buffer_cf_ratio,
                "maturity_days": all_maturity_days[i],
                "base_rate": base_rate_val,
                "nominal": all_nominal[i]
            })
            
            # Update buffer for next tranche
            buffer = new_buffer
        
        # Split results by class
        class_a_results = [r for r in results if r['is_class_a']]
        class_b_results = [r for r in results if not r['is_class_a']]
        
        # Calculate key metrics
        class_a_principal = sum(r['principal'] for r in class_a_results)
        class_b_principal = sum(r['principal'] for r in class_b_results)
        class_a_interest = sum(r['interest'] for r in class_a_results)
        class_b_coupon = sum(r['coupon_payment'] for r in class_b_results)
        class_a_total = sum(r['total_payment'] for r in class_a_results)
        class_b_total = sum(r['total_payment'] for r in class_b_results)
        
        # Calculate Class B effective coupon rate (annualized)
        if class_b_results and class_b_principal > 0:
            class_b_maturity_days = class_b_results[0]['maturity_days']
            class_b_coupon_rate = (class_b_coupon / class_b_principal) * (365 / class_b_maturity_days) * 100
        else:
            class_b_coupon_rate = 0.0
        
        min_buffer_actual = min(r['buffer_cf_ratio'] for r in class_a_results) if class_a_results else 0.0
        
        # Check if valid
        is_valid = min_buffer_actual >= min_buffer
        
        # Collect results
        result_dict = {
            'class_a_principal': class_a_principal,
            'class_b_principal': class_b_principal,
            'class_a_interest': class_a_interest, 
            'class_b_coupon': class_b_coupon,
            'class_a_total': class_a_total,
            'class_b_total': class_b_total,
            'min_buffer_actual': min_buffer_actual,
            'total_principal': class_a_principal + class_b_principal,
            'class_b_coupon_rate': class_b_coupon_rate,
            'num_a_tranches': len(a_maturity_days)
        }
        
        # Calculate weighted score based on principal and coupon rate match
        coupon_rate_diff = abs(class_b_coupon_rate - target_class_b_coupon_rate)
        coupon_rate_weight = 1.0 / (1.0 + coupon_rate_diff / 10.0)  # Penalty for difference
        weighted_principal = result_dict['total_principal'] * coupon_rate_weight
        
        return {
            'is_valid': is_valid,
            'score': weighted_principal if is_valid else 0,
            'results': result_dict if is_valid else None,
            'b_nominal': class_b_nominal
        }
    
    except Exception as e:
        # Return invalid result on any error
        logger.error(f"Error in evaluate_params: {str(e)}")
        logger.debug(traceback.format_exc())
        return {
            'is_valid': False,
            'score': 0,
            'results': None,
            'error': str(e),
            'b_nominal': class_b_nominal
        }

def perform_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Perform ABS structure optimization with improved coupon rate targeting
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    
    # Initialize progress tracking
    optimization_progress.update(step=0, total=100, 
                                phase="Standard Optimization", 
                                message="Starting standard optimization...")
    
    # Extract settings
    min_a_tranches, max_a_tranches = optimization_settings.a_tranches_range
    maturity_range = optimization_settings.maturity_range
    maturity_step = optimization_settings.maturity_step
    min_class_b_percent = optimization_settings.min_class_b_percent
    target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
    additional_days = optimization_settings.additional_days_for_class_b
    
    # Get selected strategies - use all if not specified
    selected_strategies = getattr(optimization_settings, "selected_strategies", 
                                ["equal", "increasing", "decreasing", "middle_weighted"])
    
    optimization_progress.update(step=5, 
                               message=f"Selected strategies: {', '.join(selected_strategies)}")
    
    # Set maximum allowed difference for coupon rate
    max_allowed_diff = 1.0  # Maximum 1% difference
    
    optimization_progress.update(step=5, 
                               message=f"Target coupon rate: {target_class_b_coupon_rate}%, preparing data...")
    
    start_date = pd.Timestamp(general_settings.start_date)
    ops_expenses = general_settings.operational_expenses
    min_buffer = general_settings.min_buffer
    
    # Get original parameters for Class A from the example data
    original_maturities_A = [61, 120, 182, 274]
    original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
    original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
    
    # Class B values (fallback values)
    class_b_maturity_orig = 300
    class_b_base_rate_orig = 0.0
    class_b_reinvest_rate_orig = 25.5
    
    optimization_progress.update(step=10, 
                               message="Creating rate lookup tables and preparing data...")
    
    # Create rate lookup tables for Class A
    maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
    maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
    
    # Calculate total nominal amount (from example)
    total_a_nominal = 1765000000  # Example from original code
    
    # Define search space
    num_a_tranches_options = range(min_a_tranches, max_a_tranches + 1)
    possible_maturities = list(range(maturity_range[0], maturity_range[1] + 1, maturity_step))
    
    optimization_progress.update(step=15, 
                               message=f"Using tranches from {min_a_tranches} to {max_a_tranches}")
    
    # Dictionaries to track best results for each strategy
    strategy_names = ["equal", "increasing", "decreasing", "middle_weighted"]
    
    best_params_by_strategy = {strategy: None for strategy in strategy_names}
    best_results_by_strategy = {strategy: None for strategy in strategy_names}
    best_weighted_principal_by_strategy = {strategy: 0 for strategy in strategy_names}
    best_coupon_rate_diff_by_strategy = {strategy: float('inf') for strategy in strategy_names}
    
    # Find last cash flow day
    last_cash_flow_day = get_last_cash_flow_day(df, start_date)
    
    optimization_progress.update(step=20, 
                               message=f"Last cash flow day: {last_cash_flow_day}")
    
    # Create a temporary copy of dataframe for calculations
    df_temp = df.copy()
    df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
    target_date = pd.Timestamp('2025-02-16')
    target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
    
    if not target_rows.empty:
        t_idx = target_rows.index[0]
        orig_cf = df_temp.at[t_idx, 'cash_flow']
        new_cf = max(0, orig_cf - ops_expenses)
        df_temp.at[t_idx, 'cash_flow'] = new_cf
    
    # Initialize progress counter
    current_iteration = 0
    
    # Calculate total iterations (approximate)
    total_maturity_combinations = 0
    for num_a_tranches in num_a_tranches_options:
        # Rough estimate of combinations, will be reduced later
        total_maturity_combinations += min(1000, len(list(itertools.combinations(possible_maturities, num_a_tranches))))
    
    # 4 strategies per maturity combo
    total_iterations = total_maturity_combinations * len(selected_strategies)
    optimization_progress.update(message=f"Estimated iterations: {total_iterations}")
    
    # Progress tracking variables
    current_phase = "Testing Configurations"
    optimization_progress.update(phase=current_phase)
    
    # Loop through Class A tranche counts
    for num_a_tranches_idx, num_a_tranches in enumerate(num_a_tranches_options):
        tranche_progress_base = 20 + (num_a_tranches_idx * 15)  # 15% progress per tranche count
        
        optimization_progress.update(
            step=tranche_progress_base,
            message=f"Testing with {num_a_tranches} Class A tranches"
        )
        
        # Minimum gap between consecutive maturities
        min_gap = 15  # In days
        
        # Create sequential maturity combinations
        maturity_combinations = []
        for maturities in itertools.combinations(possible_maturities, num_a_tranches):
            # Check if sorted and with minimum gap
            sorted_maturities = sorted(maturities)
            if all(sorted_maturities[i+1] - sorted_maturities[i] >= min_gap for i in range(len(sorted_maturities)-1)):
                maturity_combinations.append(sorted_maturities)
        
        # If too many combinations, sample a reasonable number
        max_samples = 30
        if len(maturity_combinations) > max_samples:
            sampled_indices = np.random.choice(len(maturity_combinations), max_samples, replace=False)
            maturity_combinations = [maturity_combinations[i] for i in sampled_indices]
        
        # Calculate progress step for this set of combinations
        combo_count = len(maturity_combinations)
        combo_progress_step = 10 / max(1, combo_count)
        
        # Process maturity combinations
        for combo_idx, maturities in enumerate(maturity_combinations):
            combo_progress = tranche_progress_base + (combo_idx * combo_progress_step)
            
            if combo_idx % 1 == 0:  # Update every 1 combinations to avoid too many updates
                optimization_progress.update(
                    step=int(combo_progress),
                    message=f"Testing maturity combination {combo_idx+1}/{combo_count}: {maturities}"
                )
            
            # Calculate Class B maturity as Last Cash Flow Day + Additional Days
            class_b_maturity = min(365, last_cash_flow_day + additional_days)
            
            # Assign rates based on nearest original Class A maturity
            a_base_rates = []
            a_reinvest_rates = []
            for m in maturities:
                nearest = get_nearest_maturity(m, original_maturities_A)
                a_base_rates.append(maturity_to_base_rate_A[nearest])
                a_reinvest_rates.append(maturity_to_reinvest_rate_A[nearest])
            
            # Use the base rate of the longest Class A tranche for Class B
            # but always use the original reinvest rate from UI
            if len(a_base_rates) > 0:
                b_base_rate = a_base_rates[-1]  # Use the base rate of the longest-maturity Class A tranche
                b_reinvest_rate = class_b_reinvest_rate_orig  # Always use original reinvest rate
            else:
                b_base_rate = class_b_base_rate_orig
                b_reinvest_rate = class_b_reinvest_rate_orig
            
            # Different nominal distribution strategies
            distribution_strategies = [
                strategy for strategy in selected_strategies 
                if strategy in ["equal", "increasing", "decreasing", "middle_weighted"]
            ]
            
            # If no valid strategies, use all
            if not distribution_strategies:
                distribution_strategies = ["equal", "increasing", "decreasing", "middle_weighted"]
                logger.warning(f"No valid strategies selected, using all: {distribution_strategies}")
            
            # Process each strategy - FIXED: Loop through each strategy
            for strategy in distribution_strategies:
                # Calculate Class B nominal based on minimum percentage
                total_nominal_amount = total_a_nominal / (1 - min_class_b_percent/100)
                class_b_nominal = total_nominal_amount * (min_class_b_percent / 100)
                remaining_nominal = total_nominal_amount - class_b_nominal
                
                # Distribute nominal amounts based on strategy
                if strategy == "equal":
                    a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                    
                elif strategy == "increasing":
                    # Weight by maturity days
                    weights = np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "decreasing":
                    # Inverse weight by maturity days
                    weights = 1 / np.array(maturities)
                    a_nominals = (weights / weights.sum()) * remaining_nominal
                    
                elif strategy == "middle_weighted":
                    # Give more weight to middle tranches
                    if num_a_tranches >= 3:
                        weights = np.ones(num_a_tranches)
                        mid_idx = num_a_tranches // 2
                        weights[mid_idx] = 1.5
                        if num_a_tranches > 3:
                            weights[mid_idx-1] = 1.3
                            weights[mid_idx+1] = 1.3
                        a_nominals = (weights / weights.sum()) * remaining_nominal
                    else:
                        a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                else:
                    # Invalid strategy, use equal distribution as fallback
                    logger.warning(f"Unknown strategy: {strategy}, using equal distribution")
                    a_nominals = [remaining_nominal / num_a_tranches] * num_a_tranches
                
                # Round to nearest 1000
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Ensure sum equals the remaining nominal
                adjustment = (remaining_nominal - sum(a_nominals)) / num_a_tranches
                a_nominals = [n + adjustment for n in a_nominals]
                a_nominals = [round(n / 1000) * 1000 for n in a_nominals]
                
                # Make final adjustment to last tranche to ensure exact total
                a_nominals[-1] += remaining_nominal - sum(a_nominals)
                
                # Now adjust the nominals to achieve target coupon rate
                adjusted_a_nominals, success = adjust_class_a_nominals_for_target_coupon(
                    a_nominals, 
                    class_b_nominal, 
                    target_class_b_coupon_rate,
                    class_b_maturity,
                    maturities, 
                    a_base_rates, 
                    a_reinvest_rates, 
                    b_base_rate, 
                    b_reinvest_rate,
                    start_date, 
                    df_temp, 
                    min_buffer,
                    max_allowed_diff
                )
                
                if success:
                    a_nominals = adjusted_a_nominals
                
                # Evaluate the result
                eval_result = evaluate_params(
                    maturities, a_nominals, 
                    class_b_maturity, start_date, df_temp,
                    maturity_to_base_rate_A, maturity_to_reinvest_rate_A,
                    b_base_rate, b_reinvest_rate,
                    min_class_b_percent, target_class_b_coupon_rate, min_buffer
                )
                
                # Check if valid and meets buffer requirement
                if eval_result['is_valid'] and eval_result['results']:
                    result_dict = eval_result['results']
                    total_principal = result_dict['total_principal']
                    class_b_coupon_rate = result_dict['class_b_coupon_rate']
                    min_buffer_actual = result_dict['min_buffer_actual']
                    
                    # Calculate difference from target coupon rate
                    coupon_rate_diff = abs(class_b_coupon_rate - target_class_b_coupon_rate)
                    
                    # Calculate weighted score based on principal and coupon rate match
                    coupon_rate_weight = np.exp(-coupon_rate_diff / 5.0)  # Stronger penalty for rate difference
                    weighted_principal = total_principal * coupon_rate_weight
                    
                    # Check if this is the best solution for this strategy
                    # Prioritize solutions with smaller coupon rate differences
                    is_better = False
                    
                    if coupon_rate_diff <= best_coupon_rate_diff_by_strategy[strategy]:
                        # If coupon rate difference is better or equal, check weighted principal
                        if coupon_rate_diff < best_coupon_rate_diff_by_strategy[strategy] or \
                           weighted_principal > best_weighted_principal_by_strategy[strategy]:
                            is_better = True
                    elif coupon_rate_diff <= max_allowed_diff and \
                         weighted_principal > best_weighted_principal_by_strategy[strategy]:
                        # If within allowed difference and better weighted principal
                        is_better = True
                    
                    if is_better:
                        best_coupon_rate_diff_by_strategy[strategy] = coupon_rate_diff
                        best_weighted_principal_by_strategy[strategy] = weighted_principal
                        
                        best_params_by_strategy[strategy] = {
                            'num_a_tranches': num_a_tranches,
                            'a_maturity_days': list(maturities),
                            'a_base_rates': a_base_rates,
                            'a_reinvest_rates': a_reinvest_rates,
                            'a_nominal_amounts': a_nominals,
                            'b_maturity_days': [class_b_maturity],
                            'b_base_rates': [b_base_rate],
                            'b_reinvest_rates': [b_reinvest_rate],
                            'b_nominal': [class_b_nominal],
                            'strategy': strategy,
                            'last_cash_flow_day': last_cash_flow_day,
                            'added_days': additional_days
                        }
                        
                        best_results_by_strategy[strategy] = {
                            'class_a_principal': result_dict['class_a_principal'],
                            'class_b_principal': result_dict['class_b_principal'],
                            'class_a_interest': result_dict['class_a_interest'],
                            'class_b_coupon': result_dict['class_b_coupon'],
                            'class_a_total': result_dict['class_a_total'],
                            'class_b_total': result_dict['class_b_total'],
                            'min_buffer_actual': min_buffer_actual,
                            'total_principal': total_principal,
                            'class_b_coupon_rate': class_b_coupon_rate,
                            'target_class_b_coupon_rate': target_class_b_coupon_rate,
                            'coupon_rate_diff': coupon_rate_diff,
                            'coupon_rate_weight': coupon_rate_weight,
                            'class_b_base_rate': b_base_rate,
                            'num_a_tranches': num_a_tranches
                        }
                        
                        optimization_progress.update(
                            message=f"Found better solution for {strategy}: coupon_rate={class_b_coupon_rate:.2f}%, " +
                                   f"diff={coupon_rate_diff:.2f}%, total_principal={total_principal:,.2f}"
                        )
                
                # Update iteration counter
                current_iteration += 1
                
                # Update progress periodically
                if current_iteration % 10 == 0:
                    progress_percent = min(80, 20 + int(current_iteration / total_iterations * 60))
                    optimization_progress.update(
                        step=progress_percent,
                        message=f"Completed {current_iteration} iterations out of approximately {total_iterations}"
                    )
    
    # Update progress to preparing results phase
    optimization_progress.update(
        step=85,
        phase="Finalizing Results",
        message="Comparing strategies and preparing results..."
    )
    
    # Compare valid strategies
    valid_strategies = {k: v for k, v in best_results_by_strategy.items() if v is not None}
    
    if not valid_strategies:
        # No valid solution found
        optimization_progress.update(
            step=90,
            message="No valid configuration found. Try adjusting optimization parameters."
        )
        raise ValueError("No valid configuration found. Try adjusting optimization parameters.")
    
    # Find best overall strategy prioritizing coupon rate match
    best_overall_strategy = min(
        valid_strategies.items(),
        key=lambda x: (x[1]['coupon_rate_diff'], -x[1]['total_principal'])
    )[0]
    
    # Get best parameters and results
    best_strategy = best_overall_strategy
    best_params = best_params_by_strategy[best_strategy]
    best_results = best_results_by_strategy[best_strategy]
    
    optimization_progress.update(
        step=95,
        message=f"Selected best strategy: {best_strategy}, coupon_rate: {best_results['class_b_coupon_rate']:.2f}%, " +
               f"diff: {best_results['coupon_rate_diff']:.2f}%, total_principal: {best_results['total_principal']:,.2f}"
    )
    
    # Extract values for the result
    class_a_maturities = best_params['a_maturity_days']
    class_a_nominals = best_params['a_nominal_amounts']
    class_a_rates = best_params['a_base_rates']
    class_a_reinvest = best_params['a_reinvest_rates']
    
    class_b_maturity = best_params['b_maturity_days'][0]
    class_b_rate = best_params['b_base_rates'][0]
    class_b_reinvest = best_params['b_reinvest_rates'][0]
    class_b_nominal = best_params['b_nominal'][0]
    
    # Final progress update
    optimization_progress.update(
        step=100,
        message="Optimization completed successfully."
    )
    
    # Return the optimization result
    return OptimizationResult(
        best_strategy=best_strategy,
        class_a_maturities=class_a_maturities,
        class_a_nominals=class_a_nominals,
        class_a_rates=class_a_rates,
        class_a_reinvest=class_a_reinvest,
        class_b_maturity=class_b_maturity,
        class_b_rate=class_b_rate,
        class_b_reinvest=class_b_reinvest,
        class_b_nominal=class_b_nominal,
        class_b_coupon_rate=best_results['class_b_coupon_rate'],
        min_buffer_actual=best_results['min_buffer_actual'],
        last_cash_flow_day=last_cash_flow_day,
        additional_days=additional_days,
        results_by_strategy={k: v for k, v in best_results_by_strategy.items() if v is not None}
    )

def perform_genetic_optimization(df: pd.DataFrame, general_settings: GeneralSettings, optimization_settings: OptimizationSettings) -> OptimizationResult:
    """Genetic algorithm optimization
    
    Args:
        df: DataFrame containing cash flow data
        general_settings: General settings for the optimization
        optimization_settings: Optimization-specific settings
        
    Returns:
        OptimizationResult object with the optimized structure
    """
    try:
        # Initialize progress tracking
        optimization_progress.update(step=0, total=100, 
                                    phase="Genetic Optimization", 
                                    message="Starting genetic algorithm optimization...")
        
        logger.info("Starting genetic algorithm optimization...")
        
        # Basic parameters
        start_date = pd.Timestamp(general_settings.start_date)
        ops_expenses = general_settings.operational_expenses
        min_buffer = general_settings.min_buffer
        min_class_b_percent = optimization_settings.min_class_b_percent
        target_class_b_coupon_rate = optimization_settings.target_class_b_coupon_rate
        additional_days = optimization_settings.additional_days_for_class_b
        population_size = getattr(optimization_settings, "population_size", 50)
        num_generations = getattr(optimization_settings, "num_generations", 40)
        
        optimization_progress.update(step=5, 
                                    message=f"Population size: {population_size}, generations: {num_generations}")
        
        logger.info(f"Parameters: population_size={population_size}, num_generations={num_generations}")
        
        # Get last cash flow day
        last_cash_flow_day = get_last_cash_flow_day(df, start_date)
        
        # Update progress to 10%
        optimization_progress.update(step=10, 
                                    message=f"Last cash flow day: {last_cash_flow_day}")
        
        # Class B maturity as Last Cash Flow Day + Additional Days, capped at 365
        class_b_maturity = min(365, last_cash_flow_day + additional_days)
        
        # Get original parameters for Class A 
        original_maturities_A = [61, 120, 182, 274]
        original_base_rates_A = [45.6, 44.5, 43.3, 42.5]
        original_reinvest_rates_A = [40.0, 37.25, 32.5, 30.0]
        
        # Class B values
        class_b_base_rate_orig = 0.0
        class_b_reinvest_rate_orig = 25.5
        
        # Create rate lookup tables for Class A
        maturity_to_base_rate_A = dict(zip(original_maturities_A, original_base_rates_A))
        maturity_to_reinvest_rate_A = dict(zip(original_maturities_A, original_reinvest_rates_A))
        
        # Update progress to 15%
        optimization_progress.update(step=15, 
                                    message="Preparing optimization data...")
        
        # Create temporary dataframe for calculation
        df_temp = df.copy()
        df_temp['cash_flow'] = df_temp['original_cash_flow'].copy()
        target_date = pd.Timestamp('2025-02-16')
        target_rows = df_temp[df_temp['installment_date'].dt.date == target_date.date()]
        
        if not target_rows.empty:
            t_idx = target_rows.index[0]
            orig_cf = df_temp.at[t_idx, 'cash_flow']
            new_cf = max(0, orig_cf - ops_expenses)
            df_temp.at[t_idx, 'cash_flow'] = new_cf
        
        # Total A nominal
        total_a_nominal = 1765000000
        
        # Fixed number of tranches
        num_a_tranches = 4
        
        # Parameter boundaries
        min_maturity = optimization_settings.maturity_range[0]
        max_maturity = optimization_settings.maturity_range[1]
        
        # Initialize population with valid individuals
        population = []
        min_gap = 15  # Minimum days between maturities
        
        optimization_progress.update(step=20, 
                                   phase="Initializing Population",
                                   message="Creating initial population...")
        
        logger.info("Initializing population...")
        
        # Function to create a valid individual
        def create_valid_individual():
            # Generate valid maturities - ensure they are integers
            maturities = []
            maturities.append(random.randint(min_maturity, min_maturity + 60))
            
            for j in range(1, num_a_tranches):
                prev_maturity = maturities[j-1]
                min_new = prev_maturity + min_gap
                max_new = min(max_maturity, prev_maturity + 120)  # Cap max gap
                
                if min_new > max_new:
                    min_new = max_new
                
                maturities.append(random.randint(min_new, max_new))
            
            # Random weights
            weights = [random.random() for _ in range(num_a_tranches)]
            total_weight = sum(weights)
            weights = [w / total_weight for w in weights]
            
            # Convert to nominals
            nominals = [w * total_a_nominal for w in weights]
            
            return {
                'maturities': maturities,
                'nominals': nominals,
                'fitness': 0  # Will be evaluated
            }
        
        # Create initial population
        failure_count = 0
        for i in range(population_size):
            try:
                individual = create_valid_individual()
                population.append(individual)
                
                # Update progress periodically
                if i % 10 == 0:
                    optimization_progress.update(
                        step=20 + int((i / population_size) * 5),
                        message=f"Initializing population: {i+1}/{population_size}"
                    )
            except Exception as e:
                logger.error(f"Error creating individual {i}: {str(e)}")
                failure_count += 1
                # Try again
                if failure_count < 50:  # Limit retries
                    i -= 1  # Retry this index
                else:
                    logger.error("Too many failures creating population, proceeding with limited population")
                    break
        
        # Ensure we have at least some individuals
        if len(population) < 5:
            optimization_progress.update(
                phase="Error",
                message="Failed to create sufficient initial population"
            )
            raise ValueError("Failed to create sufficient initial population")
        
        # Update progress to 25%
        optimization_progress.update(step=25, 
                                   phase="Evolution",
                                   message="Starting genetic algorithm evolution...")
        
        # Evolution loop
        best_individual = None
        best_fitness = -float('inf')
        
        logger.info("Starting genetic algorithm evolution...")
        
        generation_progress_step = 50 / num_generations  # 50% of progress for generations
        
        # Tournament selection function
        def tournament_select(pop, tournament_size=3):
            if not pop:
                raise ValueError("Empty population for tournament selection")
                
            contestants = random.sample(pop, min(tournament_size, len(pop)))
            return max(contestants, key=lambda x: x.get('fitness', -float('inf')))
        
        for generation in range(num_generations):
            # Update progress for each generation
            generation_progress = 25 + int(generation * generation_progress_step)
            optimization_progress.update(
                step=generation_progress,
                message=f"Generation {generation+1} of {num_generations}"
            )
            
            logger.info(f"Generation {generation+1} of {num_generations}")
            
            # Evaluate fitness
            fitness_sum = 0
            valid_count = 0
            
            for idx, individual in enumerate(population):
                try:
                    maturities = individual['maturities']
                    nominals = individual['nominals']
                    
                    # Ensure maturities are integers for evaluation
                    maturities_int = [int(m) for m in maturities]
                    
                    result = evaluate_params(
                        maturities_int, nominals, 
                        class_b_maturity, start_date, df_temp,
                        maturity_to_base_rate_A, maturity_to_reinvest_rate_A,
                        class_b_base_rate_orig, class_b_reinvest_rate_orig,
                        min_class_b_percent, target_class_b_coupon_rate, min_buffer
                    )
                    
                    # Set fitness - ensure it's a number
                    if result['is_valid']:
                        individual['fitness'] = float(result['score'])
                        individual['result'] = result
                        fitness_sum += individual['fitness']
                        valid_count += 1
                    else:
                        individual['fitness'] = -1.0 # Invalid but better than -inf for selection
                        individual['result'] = None
                    
                    # Track the best
                    if individual['fitness'] > best_fitness:
                        best_fitness = individual['fitness']
                        best_individual = individual.copy()
                        logger.info(f"Found better solution: score={best_fitness}")
                        
                        # Update progress message when finding better solution
                        if 'result' in individual and individual['result'] and 'results' in individual['result']:
                            if 'class_b_coupon_rate' in individual['result']['results']:
                                coupon_rate = individual['result']['results']['class_b_coupon_rate']
                                coupon_diff = abs(coupon_rate - target_class_b_coupon_rate)
                                optimization_progress.update(
                                    message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}, coupon rate: {coupon_rate:.2f}% (diff: {coupon_diff:.2f}%)"
                                )
                        else:
                            optimization_progress.update(
                                message=f"Generation {generation+1}: Found better solution with score {best_fitness:.2f}"
                            )
                except Exception as e:
                    logger.error(f"Error evaluating individual {idx} in generation {generation}: {str(e)}")
                    # Set very low fitness to avoid selection
                    individual['fitness'] = -float('inf')
                    individual['result'] = None
            
            # Log average fitness for valid individuals
            if valid_count > 0:
                avg_fitness = fitness_sum / valid_count
                logger.info(f"Generation {generation+1} average fitness: {avg_fitness:.2f} ({valid_count} valid individuals)")
            
            # Create next generation
            new_population = []
            
            # Elitism - keep best individuals
            sorted_pop = sorted(population, key=lambda x: x.get('fitness', -float('inf')), reverse=True)
            elite_count = max(2, population_size // 10)
            new_population.extend(sorted_pop[:elite_count])
            
            # Fill rest with crossover and mutation
            crossover_attempts = 0
            while len(new_population) < population_size and crossover_attempts < population_size * 2:
                crossover_attempts += 1
                try:
                    # Tournament selection
                    parent1 = tournament_select(population)
                    parent2 = tournament_select(population)
                    
                    # Crossover - mix maturities
                    child_maturities = []
                    for i in range(num_a_tranches):
                        # 50% chance from each parent
                        if random.random() < 0.5:
                            child_maturities.append(parent1['maturities'][i])
                        else:
                            child_maturities.append(parent2['maturities'][i])
                    
                    # Ensure maturities are valid integers
                    child_maturities = sorted([int(m) for m in child_maturities])
                    
                    # Fix any invalid gaps
                    for i in range(1, num_a_tranches):
                        if child_maturities[i] - child_maturities[i-1] < min_gap:
                            child_maturities[i] = child_maturities[i-1] + min_gap
                    
                    # Weight crossover with averaging
                    child_weights = []
                    for i in range(num_a_tranches):
                        weight1 = parent1['nominals'][i] / total_a_nominal
                        weight2 = parent2['nominals'][i] / total_a_nominal
                        child_weights.append((weight1 + weight2) / 2)
                    
                    # Normalize weights
                    total_weight = sum(child_weights)
                    child_weights = [w / total_weight for w in child_weights]
                    child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Mutation - mutate maturities
                    if random.random() < 0.3:  # 30% mutation rate
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        
                        # Different mutation for different positions
                        if mutation_idx == 0:
                            # First maturity
                            child_maturities[0] = random.randint(min_maturity, min(child_maturities[1] - min_gap, min_maturity + 60))
                        elif mutation_idx == num_a_tranches - 1:
                            # Last maturity
                            child_maturities[-1] = random.randint(child_maturities[-2] + min_gap, max_maturity)
                        else:
                            # Middle maturity
                            min_val = child_maturities[mutation_idx-1] + min_gap
                            max_val = child_maturities[mutation_idx+1] - min_gap
                            
                            if min_val < max_val:
                                child_maturities[mutation_idx] = random.randint(min_val, max_val)
                    
                    # Mutation - mutate weights
                    if random.random() < 0.3:
                        mutation_idx = random.randint(0, num_a_tranches-1)
                        mutation_amount = random.uniform(-0.1, 0.1)
                        child_weights[mutation_idx] = max(0.1, min(0.4, child_weights[mutation_idx] + mutation_amount))
                        
                        # Renormalize
                        total_weight = sum(child_weights)
                        child_weights = [w / total_weight for w in child_weights]
                        child_nominals = [w * total_a_nominal for w in child_weights]
                    
                    # Add child to new population
                    new_population.append({
                        'maturities': child_maturities,  # These are already integers
                        'nominals': child_nominals,
                        'fitness': 0  # Will be evaluated in next generation
                    })
                except Exception as e:
                    logger.error(f"Error in crossover/mutation: {str(e)}")
                    continue
            
            # If we couldn't create enough children, fill with new random individuals
            while len(new_population) < population_size:
                try:
                    new_population.append(create_valid_individual())
                except Exception as e:
                    logger.error(f"Error creating new individual to fill population: {str(e)}")
                    # If we failed a few times, just break and proceed with smaller population
                    if len(new_population) > population_size * 0.7:
                        break
            
            # Replace population
            population = new_population
            
            # Early termination if we have an excellent solution
            if best_individual and best_individual.get('result') and best_individual['result'].get('results'):
                best_results = best_individual['result']['results']
                if 'class_b_coupon_rate' in best_results:
                    coupon_diff = abs(best_results['class_b_coupon_rate'] - target_class_b_coupon_rate)
                    if coupon_diff < 0.2:
                        optimization_progress.update(
                            message=f"Found excellent solution (coupon diff < 0.2%), ending evolution early"
                        )
                        break
        
        # Update to 75% progress
        optimization_progress.update(step=75, 
                                phase="Finalizing",
                                message="Evolution complete, preparing final results...")
        
        # If no valid solution found
        if best_individual is None or best_fitness <= 0:
            optimization_progress.update(
                step=80,
                phase="Error",
                message="Genetic optimization failed: No valid solution found"
            )
            logger.error("Genetic optimization failed: No valid solution found")
            # Fall back to classic optimization
            optimization_progress.update(
                message="Falling back to classic optimization method..."
            )
            return perform_optimization(df, general_settings, optimization_settings)
        
        # Get the best result
        best_maturities = best_individual['maturities']
        best_nominals = best_individual['nominals']
        best_result = best_individual['result']
        
        # Get rates based on original data
        best_base_rates = [maturity_to_base_rate_A.get(get_nearest_maturity(m, original_maturities_A), 42.0) for m in best_maturities]
        best_reinvest_rates = [maturity_to_reinvest_rate_A.get(get_nearest_maturity(m, original_maturities_A), 30.0) for m in best_maturities]
        
        optimization_progress.update(step=90, 
                                message="Creating optimization result...")
        
        logger.info("Genetic optimization completed successfully")
        
        # Prepare the result - ensure all values are of correct types
        result = OptimizationResult(
            best_strategy="genetic",
            class_a_maturities=[int(m) for m in best_maturities],  # Ensure integers
            class_a_nominals=best_nominals,
            class_a_rates=best_base_rates,
            class_a_reinvest=best_reinvest_rates,
            class_b_maturity=int(class_b_maturity),
            class_b_rate=class_b_base_rate_orig,
            class_b_reinvest=class_b_reinvest_rate_orig,
            class_b_nominal=best_result.get('b_nominal', 0),
            class_b_coupon_rate=best_result['results'].get('class_b_coupon_rate', 0),
            min_buffer_actual=best_result['results'].get('min_buffer_actual', 0),
            last_cash_flow_day=int(last_cash_flow_day),
            additional_days=int(additional_days),
            results_by_strategy={"genetic": best_result['results']}
        )
        
        # Final progress update to 100%
        optimization_progress.update(step=100, 
                                phase="Complete",
                                message="Genetic optimization completed successfully")
        
        return result
    except Exception as e:
        # Handle any exceptions
        logger.error(f"Error in genetic optimization: {str(e)}")
        logger.debug(traceback.format_exc())
        
        # Fall back to classic optimization
        optimization_progress.update(
            step=80,
            phase="Error Recovery",
            message=f"Error in genetic optimization: {str(e)}. Falling back to classic optimization method..."
        )
        return perform_optimization(df, general_settings, optimization_settings)

======================================================================

DOSYA: backend\app\utils\cash_flow_utils.py
==================================================
"""
Utility functions for cash flow processing and tranche calculations.
"""
import pandas as pd
import numpy as np
from datetime import timedelta
from typing import List, Dict, Any, Tuple
from app.utils.finance_utils import (
    get_next_business_day,
    simple_to_compound_annual,
    calculate_reinvestment_date
)

def assign_cash_flows_to_tranches(
    df: pd.DataFrame, 
    start_date: pd.Timestamp, 
    all_maturity_dates: List[pd.Timestamp], 
    all_reinvest_rates: List[float]
) -> List[List[Dict[str, Any]]]:
    """
    Distribute cash flows into tranches, adjust for weekends,
    and calculate reinvestment returns.
    
    Args:
        df: DataFrame containing cash flow data
        start_date: Start date for calculations
        all_maturity_dates: List of maturity dates for each tranche
        all_reinvest_rates: List of reinvestment rates for each tranche
        
    Returns:
        List of cash flow lists for each tranche
    """
    num_tranches = len(all_maturity_dates)
    tranch_cash_flows = [[] for _ in range(num_tranches)]
    
    for idx, row in df.iterrows():
        inst_date = row['installment_date']
        cf = row['cash_flow']
        principal_amt = row.get('principal_amount', 0)
        interest_amt = row.get('interest_amount', 0)
        
        if pd.isnull(inst_date) or inst_date < start_date:
            continue
        
        reinvest_date = calculate_reinvestment_date(inst_date)
        assigned = False
        
        # First pass - assign to the first matching tranche
        for i in range(num_tranches):
            if inst_date < all_maturity_dates[i]:
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    assigned = True
                    break
        
        # If not assigned in first pass
        if not assigned and num_tranches > 0:
            # Second pass - assign based on reinvest date
            re_assign = False
            for i in range(num_tranches):
                if reinvest_date < all_maturity_dates[i]:
                    days_diff = (all_maturity_dates[i] - reinvest_date).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        r_return = cf * factor
                    else:
                        r_return = 0.0
                    tranch_cash_flows[i].append({
                        'date': inst_date,
                        'cash_flow': cf,
                        'principal_amount': principal_amt,
                        'interest_amount': interest_amt,
                        'reinvest_date': reinvest_date,
                        'reinvestment_return': r_return,
                        'moved_from': None
                    })
                    re_assign = True
                    break
            
            # If still not assigned, put in the last tranche
            if not re_assign:
                last_idx = num_tranches - 1
                days_diff = (all_maturity_dates[last_idx] - reinvest_date).days
                if days_diff > 0:
                    r_compound = simple_to_compound_annual(all_reinvest_rates[last_idx]) / 100.0
                    factor = (1 + r_compound)**(days_diff/365) - 1
                    r_return = cf * factor
                else:
                    r_return = 0.0
                tranch_cash_flows[last_idx].append({
                    'date': inst_date,
                    'cash_flow': cf,
                    'principal_amount': principal_amt,
                    'interest_amount': interest_amt,
                    'reinvest_date': reinvest_date,
                    'reinvestment_return': r_return,
                    'moved_from': None,
                    'note': 'Reinvestment date >= all'
                })
    
    # Third pass: if reinvest_date >= current tranche maturity, move the cash flow to a later tranche
    for i in range(num_tranches-1):
        final_cf = []
        for cf_info in tranch_cash_flows[i]:
            if cf_info['reinvest_date'] >= all_maturity_dates[i]:
                moved = False
                for j in range(i+1, num_tranches):
                    if cf_info['reinvest_date'] < all_maturity_dates[j]:
                        days_diff = (all_maturity_dates[j] - cf_info['reinvest_date']).days
                        if days_diff > 0:
                            r_compound = simple_to_compound_annual(all_reinvest_rates[j]) / 100.0
                            factor = (1 + r_compound)**(days_diff/365) - 1
                            new_ret = cf_info['cash_flow'] * factor
                        else:
                            new_ret = 0.0
                        new_cf = dict(cf_info)
                        new_cf['reinvestment_return'] = new_ret
                        new_cf['moved_from'] = i
                        tranch_cash_flows[j].append(new_cf)
                        moved = True
                        break
                
                if not moved and (i+1) < num_tranches:
                    last_i = num_tranches - 1
                    days_diff = (all_maturity_dates[last_i] - cf_info['reinvest_date']).days
                    if days_diff > 0:
                        r_compound = simple_to_compound_annual(all_reinvest_rates[last_i]) / 100.0
                        factor = (1 + r_compound)**(days_diff/365) - 1
                        new_ret = cf_info['cash_flow'] * factor
                    else:
                        new_ret = 0.0
                    new_cf = dict(cf_info)
                    new_cf['reinvestment_return'] = new_ret
                    new_cf['moved_from'] = i
                    tranch_cash_flows[last_i].append(new_cf)
            else:
                final_cf.append(cf_info)
        
        tranch_cash_flows[i] = final_cf
    
    return tranch_cash_flows

def calculate_totals(
    cash_flows: List[Dict[str, Any]], 
    maturity_date: pd.Timestamp, 
    reinvest_rate: float
) -> Tuple[float, float, float, float]:
    """
    Calculate totals for a tranche.
    
    Args:
        cash_flows: List of cash flow information dictionaries
        maturity_date: Maturity date for the tranche
        reinvest_rate: Reinvestment rate for the tranche
        
    Returns:
        Tuple of (total_cash_flow, total_reinvest, total_principal, total_interest)
    """
    r_comp = simple_to_compound_annual(reinvest_rate)
    total_cash_flow = 0.0
    total_principal = 0.0
    total_interest = 0.0
    total_reinvest = 0.0
    
    for c in cash_flows:
        cf = c['cash_flow']
        principal = c.get('principal_amount', 0)
        interest = c.get('interest_amount', 0)
        
        total_cash_flow += cf
        total_principal += principal
        total_interest += interest
        
        rd = c['reinvest_date']
        days_diff = (maturity_date - rd).days
        
        if days_diff > 0:
            factor = (1 + r_comp/100)**(days_diff/365) - 1
            ret = cf * factor
            total_reinvest += ret
    
    return total_cash_flow, total_reinvest, total_principal, total_interest

======================================================================

DOSYA: backend\app\utils\finance_utils.py
==================================================
# backend/app/utils/finance_utils.py
import pandas as pd
from datetime import datetime, timedelta

def simple_to_compound_annual(simple_rate_percent):
    """Convert an annual simple rate (in %) to an annual compounded rate (in %)."""
    r_simple = simple_rate_percent / 100.0
    # daily rate under simple assumption:
    r_daily = r_simple / 365
    annual_compound = (1 + r_daily)**365 - 1
    return annual_compound * 100.0

def simple_to_maturity_compound(simple_rate_percent, days):
    """Convert a simple rate over 'days' to an equivalent annual compounded rate."""
    if days <= 0:
        return 0.0
    r_simple = simple_rate_percent / 100.0
    period_simple = r_simple * (days / 365)  # portion of the year
    period_compound = (1 + period_simple)**(365 / days) - 1
    return period_compound * 100.0

def overnight_to_annual_compound(simple_rate_percent):
    """Convert an annual simple rate to annual compound."""
    daily_rate = simple_rate_percent / 365 / 100
    annual_compound = (1 + daily_rate)**365 - 1
    return annual_compound * 100.0

def get_next_business_day(date):
    """If the date falls on a weekend, move it to the next business day."""
    while date.weekday() >= 5:  # 5=Saturday, 6=Sunday
        date += timedelta(days=1)
    return date

def calculate_reinvestment_date(installment_date):
    """Adjust the installment date for weekends and add 1 day."""
    if installment_date.weekday() >= 5:
        installment_date = get_next_business_day(installment_date)
    reinvest_date = installment_date + timedelta(days=1)
    reinvest_date = get_next_business_day(reinvest_date)
    return reinvest_date

def get_nearest_maturity(target_maturity, available_maturities):
    """Find the closest maturity day in the available maturities."""
    return min(available_maturities, key=lambda x: abs(x - target_maturity))

def get_last_cash_flow_day(df, start_date):
    """Find the last cash flow day and calculate as days from start date."""
    start_date = pd.Timestamp(start_date)
    last_cash_flow_date = df['installment_date'].max()
    
    if pd.notna(last_cash_flow_date):
        days = (last_cash_flow_date - start_date).days
        return max(0, days)  # Should not be negative
    else:
        return 365  # Default value

======================================================================

